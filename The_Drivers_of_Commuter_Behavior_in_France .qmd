---
title: "The Drivers of Commuter Behavior in France"
author: "Mathilde VALLAT, Yesmine HACHANA"
format: html
editor: 
  markdown: 
    wrap: 72
---

Link to the github project:
https://github.com/jemappelleyesmine/final_project

# Datasets

## Links to the sources

### INSEE_Statistiques_locales_demographie.csv

Source: https://statistiques-locales.insee.fr/#view=map1&c=indicator To
reproduce the data selection: In "CHOISIR DES INDICATEURS", go to
DÉMOGRAPHIE, then select: - Population municipale (historique depuis
1876) 2021 - Densité de population (historique depuis 1876) 2021 In
"CHANGER LE DÉCOUPAGE GÉOGRAPHIQUE", select: -
Intercommunalité-Métropole

### INSEE_Statistiques_locales_menages_fiscaux_niveau_de_vie.csv

Source: https://statistiques-locales.insee.fr/#view=map1&c=indicator To
reproduce the data selection: In "CHOISIR DES INDICATEURS", go to
REVENUS - POUVOIR D'ACHAT - CONSOMMATION, then select: - Nb de ménages
fiscaux 2021 - Médiane du niveau de vie 2021 In "CHANGER LE DÉCOUPAGE
GÉOGRAPHIQUE", select: - Commune

### INSEE_Statistiques_locales_territoires_ville_quartiers.csv

Source: https://statistiques-locales.insee.fr/#view=map1&c=indicator To
reproduce the data selection: In "CHOISIR DES INDICATEURS", go to
TERRITOIRES, VILLES ET QUARTIERS, then select: - Part des actifs occupés
de 15 ans ou plus les transports en commun 2021 - Part des ménages ayant
au moins 1 voiture 2021 - Part des actifs occ 15 ans ou plus voiture
pour travailler 2021 - Part des actifs occ 15 ans ou plus vélo pour
travailler 2021 In "CHANGER LE DÉCOUPAGE GÉOGRAPHIQUE", select: -
Commune

### stops_france.csv.gz

Source:
https://transport.data.gouv.fr/datasets/arrets-de-transport-en-france

### RP2021_mobpro.zip

Source: https://www.insee.fr/fr/statistiques/8205896?sommaire=8205966

### BTT_TD_NAV2B_2017.zip

Source:
https://www.insee.fr/fr/statistiques/4515510?sommaire=4516095&q=mobilite+et+transports#consulter
To reproduce the data selection: "NAV2B – Population active de 15 ans ou
plus ayant un emploi par sexe, lieu de travail (géographie urbaine) et
moyen de transport"

## Loading the three final datasets

### Loading stops_france

```{r}
library(vroom)
library(here)
here::i_am("Final_Project_Commuter_behavior.Rproj")

source <- "https://www.data.gouv.fr/fr/datasets/r/69cf54c6-6591-4920-b1d6-2a5292964606"
local_name <- "stops_france.csv.gz"
local_dir <- "data"
## is the directory available?
if (!dir.exists(here(local_dir))) {
  ## create the directory if needed
  dir.create(here(local_dir))
}
## is the file available?
if (!file.exists(here(local_dir, local_name))) {
  ## we need to download it
  stops_france <- vroom(source)
  ## let's save the file to avoid useless downloading
  vroom_write(stops_france, here(local_dir, local_name), delim = ",")
} else {
  ## we need only to load it
  stops_france <- vroom(here(local_dir, local_name))
}
```

### Loading mob_pro

```{r}
library(zip)
# Define variables
source <- "https://www.insee.fr/fr/statistiques/fichier/8205896/RP2021_mobpro.zip"
local_name <- "RP2021_mobpro.zip"
local_dir <- "data"
csv1_name <- "FD_MOBPRO_2021.csv"
csv2_name <- "varmod_mobpro_2021.csv"
# Check if the directory exists, create if not
if (!dir.exists(here(local_dir))) {
  dir.create(here(local_dir))
}
# Check if the ZIP file exists locally
if (!file.exists(here(local_dir, local_name))) {
  # Download the ZIP file
  download.file(source, destfile = here(local_dir, local_name), mode = "wb")
}
# Unzip the file
unzip(here(local_dir, local_name), exdir = here(local_dir))
# Load the first CSV file
mob_pro <- vroom(here(local_dir, csv1_name))
# Load the second CSV file
var_mob_pro <- vroom(here(local_dir, csv2_name))
```

### Loading iltduu_sexe_trans

```{r}
# Define variables
source <- "https://www.insee.fr/fr/statistiques/fichier/4515510/BTT_TD_NAV2B_2017.zip"
local_name <- "BTT_TD_NAV2B_2017.zip"
local_dir <- "data"
csv_name <- "BTT_TD_NAV2B_2017.CSV"
# Check if the directory exists, create it if not
if (!dir.exists(here(local_dir))) {
  dir.create(here(local_dir))
}
# Check if the ZIP file exists locally
if (!file.exists(here(local_dir, local_name))) {
  # Download the ZIP file
  download.file(source, destfile = here(local_dir, local_name), mode = "wb")
}
# Unzip the file
unzip(here(local_dir, local_name), exdir = here(local_dir))
# Load the specified CSV file
iltduu_sexe_trans <- vroom(here(local_dir, csv_name))
```

## Loading the local files

```{r}
demo <- vroom(here("data", "INSEE_Statistiques_locales_demographie.csv"))
revenus <- vroom(here("data","INSEE_Statistiques_locales_menages_fiscaux_niveau_de_vie.csv"))
local_mob <- vroom(here("data","INSEE_Statistiques_locales_territoires_ville_quartiers.csv"))
```

# Project Description

## Description of the sources

Our first source is the “Statistiques Locales” platform by INSEE. This
platform provides geolocalized data to analyze territorial / spatial
phenomena in France. It is an online tool that can allow us to have
access to statistical information (which are categorized by geographic
areas) through tables . Most importantly for us, it offers datasets on
urban and travel indicators. There are three datasets from this platform
which we are interested in: The data tab called “Territoires, villes et
quartiers” (especially its sub-tab “Mobilités - Déplacements”). The data
tab called “Démographie” (notably its data on population density by
geography). The data tab called “Développement Durable - Environnement”,
which provides a data set on the median standard of living in France by
geographical area (“commune”).

Our second source is an experimental dataset published on the
governmental website transport.data.gouv.fr by the “Ministère du
partenariat avec les territoires et de la décentralisation”. This
platform provides a dataset of public transport stop points across
France. This dataset aggregates GTFS (General Transit Feed
Specification) data collected from the National Access Point for
transport data. It includes the name, coordinates (longitude and
latitude), region, mobility authority (if applicable), and GTFS
identifiers of each stop. The data set has limitations such as
duplication of stops.

Our third source is INSEE's December 2020 dataset on commuting patterns
from the 2017 population census. This dataset, titled NAV2B, focuses on
employed individuals aged 15 and older, sharing their means of
transportation for commuting to work, disaggregated by gender and
workplace geography (urban vs. rural). It provides granular data at the
municipal level for all French communes except Mayotte.

Our final source is an INSEE 2024 dataset on professional mobility, from
the 2021 population It contains data linking individuals' places of
residence and work at the municipal level, including cross-border
commuting. It provides information on individuals aged 15 and older who
are employed, with variables describing their household, primary
residence, and commuting patterns.

```{r}
# Load required libraries
library(tibble)
library(knitr)

# Define datasets
datasets <- list(
  iltduu_sexe_trans = iltduu_sexe_trans,
  stops_france = stops_france,
  mob_pro = mob_pro,
  var_mob_pro = var_mob_pro,
  revenus = revenus,
  demo = demo,
  local_mob = local_mob
)

# Generate a table for each dataset
for (name in names(datasets)) {
  # Access the dataset
  data <- datasets[[name]]
  # Compute basic information
  summary_table <- tibble(
    Statistic = c(
      "Number of Rows",
      "Number of Columns"
    ),
    Value = c(
      nrow(data),
      ncol(data)
    )
  )
  # Print a heading and the table
  cat("\n### Summary Table for Dataset:", name, "\n")
  print(kable(summary_table))
  cat("\n")
}
```

## Description of the research question

Our research question is: “What are the drivers influencing commuter
choices in France?” Understanding what influences individuals’ commuting
choices in France can provide insights into environmental policy and
urban planning. Commuter behavior reflects socio-economic, geographic,
and infrastructural factors, which shape transportation systems, urban
development, and sustainability efforts. This project seeks to explore
possible key drivers of commuter choices, with a focus on big datasets
with different levels of aggregation. We chose to investigate several
factors influencing commuter behavior based on the availability of
datasets and the type of information that could be publicly available.
Here are some factors that we have thought of: Type of Area (Urban or
Rural) – Commuting options and preferences may differ between urban and
rural areas due to infrastructure availability, population density, and
economic activity.

-   Socio-Professional Category and Income Levels – Professional status
    and income levels might play a role in transportation choices
    (affordability, accessibility).

-   Population Density – Denser areas may encourage the use of public
    transit and non-motorized options, while less dense regions may rely
    more heavily on private vehicles.

-   Commuting Distance – The length of the commute is an important
    variable, as it could dictate whether an individual opts for
    walking, cycling, driving, or public transit.

-   Accessibility to Transportation Infrastructure – The availability of
    public transit could affect convenience and practicality.

Our project involves several steps: firstly, we must collect, store, and
organize datasets in a GitHub repository. Since datasets are aggregated
at varying levels (e.g., “commune” vs. “intercommunal”), we will have to
harmonize these differences using data management methods seen in class.
In parallel, we will have to look for missing or inconsistent data that
may complicate our data analysis. After this, we will start initial data
exploration by trying to summarize variables and visualize relationships
using R. At the end, the goal will be to generate visualizations to
identify patterns and evaluate the influence of each factor on commuter
behavior. The biggest challenge will probably be harmonizing datasets
with differing levels of aggregation, such as municipal and regional
data. For now, our expectations are to successfully manage to clean the
data, and find some drivers of commuter behavior in France and manage to
generate clear and simple ways to visualize and understand those
patterns.

## Description of dataset inclusion

A first challenge was to try to include large datasets. We wrote code in
R that ensures files are downloaded, saved, and loaded regardless of the
size limit on Github. For the first dataset called stops_france, we used
the vroom and here packages. The code checks if a local directory named
data exists, creating it if necessary. It then checks whether the
dataset file is already stored locally. If the file is missing, it
downloads the dataset from the source and saves it in a compressed
format (.gz). If the file is already available, it is loaded directly
from the local directory. The second dataset, mob_pro, is a ZIP file
containing multiple CSV files. After confirming the data directory
exists, the code checks for the presence of the ZIP file locally. If it
is not found, the file is downloaded and extracted into the data
directory. The extracted CSV files are then loaded individually using
the vroom package. So far, we have not cleaned or joined the data.
Cleaning will include handling missing values and selecting relevant
variables. Joining will involve combining datasets with different levels
of aggregation, such as linking geographic data with socio-economic
indicators. These will be our next steps!

## Description of the main variables

### "Statistiques Locales" Platform by INSEE

#### "Territoires, villes et quartiers" data tab

**“Part des actifs occupés de 15 ans ou plus qui utilisent
principalement les transports en commun pour aller travailler”**: This
variable represents the proportion of employed individuals aged 15 and
older who primarily rely on public transportation for commuting to work
in 2021. It is categorized by commune.

#### "Démographie" data tab

**"Densité de population"**: This variable represents the population
density, calculated as the number of inhabitants (municipal count) per
square kilometer, for each intercommunal area, since 1876.

#### "Développement durable - Environnement" data tab

**"Médiane du niveau de vie"**: This variable represents, across
communes, the median disposable income per household, calculated by
dividing the household's total disposable income by the number of
consumption units. It excludes small zones with fewer than 50 households
or 100 individuals for statistical confidentiality.

### Experimental dataset from transport.data.gouv.fr

**"stop_name"**: This variable represents the name of a public
transportation stop, as listed in the experimental dataset from
transport.data.gouv.fr. Each stop is geolocated using its latitude and
longitude. The dataset aggregates stops from multiple GTFS files, and
the stop names are not deduplicated, meaning multiple entries can
correspond to the same physical stop across different datasets.

### INSEE's December 2020 NAV2B data set

**“TRANS_19”** : This variable categorizes the primary mode of
transportation used by employed individuals aged 15 years and above for
commuting, by commune. The modes include walking, cycling, public
transport, private vehicles (car, van, truck), motorized two-wheelers,
and no transportation (e.g., work from home).

**“ILTDUU”**: This variable categorizes the commuting pattern of
individuals based on the urban or rural classification of their
residence and workplace. The categories include living and working in
the same rural or urban commune, commuting from a rural area to another
rural or urban commune, or commuting from an urban area to other urban
or rural locations.

### INSEE's 2024 dataset on professional mobility

**"DEROU"**: This variable represents the number of motorized
two-wheelers (such as motorcycles or scooters) owned by the household.

**"DIPL"**: This variable indicates the highest level of educational
qualification achieved by an individual.

**"INPOM"**: This variable provides the count of employed individuals
within a household.

**"VOIT"**: This variable represents the number of cars owned by the
household.

**"COMMUNE"**: Refers to the municipality or town of residence or work.

**"ILT"**: Indicates the location of an individual's workplace relative
to their residence, categorized into five groups: within the same
municipality, a different municipality in the same department, another
department in the same region, another region in metropolitan France, or
outside metropolitan France (including overseas or abroad).

## Graphical representation of one of the main variables

```{r}
# Load libraries
library(dplyr)
library(ggplot2)
```

```{r}
# Remove rows where nb is na
iltduu_sexe_trans <- iltduu_sexe_trans %>%
  filter(!is.na(NB))
```

```{r}
# checking there are no missing values there
any(is.na(iltduu_sexe_trans$NB))
```

```{r}
library(dplyr)
library(ggplot2)
library(scales) # formatting the numbers :)

# Summarizing our data to get counts for each transport mode
trans_19_summary <- iltduu_sexe_trans %>%
  group_by(TRANS_19) %>%
  summarise(Count = sum(NB)) # Sum the NB column for each transport mode

# Mapping the transport modes to their labels
trans_19_summary$Mode <- factor(trans_19_summary$TRANS_19,
  levels = 1:6,
  labels = c("No Transport", "Walking", "Bicycle", "Motorized Two-Wheelers", "Car/Truck/Van", "Public Transport")
)

# Creating the graphical representation (after everything)
ggplot(trans_19_summary, aes(x = Mode, y = Count, fill = Mode)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(
    title = "Distribution of Transport Modes (TRANS_19)",
    x = "Mode of Transport",
    y = "Count of Individuals"
  ) +
  scale_y_continuous(labels = label_comma()) + # Format y-axis labels
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

# Data Cleaning

## Identify and handle missing values

### Checking for missing values

```{r}
library(dplyr)
library(tidyr)

# Create a function to summarize missing values
summarize_missing <- function(dataset) {
  missing_summary <- dataset %>%
    summarise(across(everything(), ~ sum(is.na(.)))) %>%
    pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")
  
  return(missing_summary)
}

# Apply the function to each dataset
datasets <- list(
  demo = demo,
  iltduu_sexe_trans = iltduu_sexe_trans,
  local_mob = local_mob,
  revenus = revenus,
  stops_france = stops_france,
  mob_pro = mob_pro,
  var_mob_pro = var_mob_pro
)

missing_values_summary <- lapply(datasets, summarize_missing)

# Print summary for each dataset
for (name in names(missing_values_summary)) {
  cat("\n### Missing Value Summary for Dataset:", name, "\n")
  print(missing_values_summary[[name]])
}
```

### Handling missing values of demo (demo_cleaned)

```{r}
library(dplyr)

# Handle missing values in 'demo'
demo_cleaned <- demo %>%
  # Replace missing values in columns (impute with placeholder "Unknown")
  mutate(
    `...2` = ifelse(is.na(`...2`), "Unknown", `...2`),
    `...3` = ifelse(is.na(`...3`), "Unknown", `...3`),
    `...4` = ifelse(is.na(`...4`), "Unknown", `...4`)
  )

# Check to confirm no missing values remain
summary_missing_cleaned <- demo_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

### Handling missing values of local_mob (local_mob_cleaned)

```{r}
# Handling missing values in local_mob
local_mob_cleaned <- local_mob %>%
  mutate(
    # Replace missing values in categorical columns with "Unknown"
    `Insee - Statistiques locales` = ifelse(is.na(`Insee - Statistiques locales`), "Unknown", `Insee - Statistiques locales`),
    `...2` = ifelse(is.na(`...2`), "Unknown", `...2`),
    
    # Replace missing values in numeric columns with the column mean
    `...3` = ifelse(is.na(`...3`), mean(as.numeric(`...3`), na.rm = TRUE), `...3`),
    `...4` = ifelse(is.na(`...4`), mean(as.numeric(`...4`), na.rm = TRUE), `...4`),
    `...5` = ifelse(is.na(`...5`), mean(as.numeric(`...5`), na.rm = TRUE), `...5`),
    `...6` = ifelse(is.na(`...6`), mean(as.numeric(`...6`), na.rm = TRUE), `...6`)
  )

# Check to confirm no missing values remain
summary_missing_cleaned <- local_mob_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

### Handling missing values of revenus (revenus_cleaned)

```{r}
# Handling missing values in the revenus dataset
revenus_cleaned <- revenus %>%
  mutate(
    `...2` = ifelse(is.na(`...2`), "Unknown", `...2`),
    `...3` = ifelse(is.na(`...3`), round(mean(as.numeric(`...3`), na.rm = TRUE)), `...3`),
    `...4` = ifelse(is.na(`...4`), median(as.numeric(`...4`), na.rm = TRUE), `...4`)
  )

# Check to confirm no missing values remain
summary_missing_cleaned <- revenus_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

### Handling missing values of stops_france (stops_france_cleaned)

```{r}
# Handling missing values and removing unnecessary columns in stops_france
stops_france_cleaned <- stops_france %>%
  select(-dataset_aom_id, -dataset_region_id) %>% # Remove columns with excessive missing values
  mutate(
    dataset_organisation = ifelse(is.na(dataset_organisation), "Unknown", dataset_organisation),
    stop_name = ifelse(is.na(stop_name), "Unnamed Stop", stop_name)
  )

# Check to confirm no missing values remain
summary_missing_cleaned <- stops_france_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

### Handling missing values of mob_pro (mob_pro_cleaned)

```{r}
# Investigate rows with missing values
missing_rows <- mob_pro %>%
  filter(is.na(INEEM) & is.na(INPOM) & is.na(INPSM) & is.na(LPRM) & 
         is.na(NPERR) & is.na(STOCD) & is.na(TYPL) & is.na(TYPMR) & is.na(VOIT))

# Check the proportion of missing rows
missing_row_count <- nrow(missing_rows)
total_row_count <- nrow(mob_pro)
proportion_missing <- missing_row_count / total_row_count

print(paste("Proportion of rows with all these variables missing:", proportion_missing))

# If the proportion of missing rows is small, remove them
if (proportion_missing < 0.05) { # Adjust threshold as necessary
  mob_pro_cleaned <- mob_pro %>%
    filter(!(is.na(INEEM) & is.na(INPOM) & is.na(INPSM) & is.na(LPRM) & 
             is.na(NPERR) & is.na(STOCD) & is.na(TYPL) & is.na(TYPMR) & is.na(VOIT)))
} else {
  # Otherwise, impute the missing values
  mob_pro_cleaned <- mob_pro %>%
    mutate(
      INEEM = ifelse(is.na(INEEM), "Unknown", INEEM),
      INPOM = ifelse(is.na(INPOM), "Unknown", INPOM),
      INPSM = ifelse(is.na(INPSM), "Unknown", INPSM),
      LPRM = ifelse(is.na(LPRM), "Unknown", LPRM),
      NPERR = ifelse(is.na(NPERR), "Unknown", NPERR),
      STOCD = ifelse(is.na(STOCD), "Unknown", STOCD),
      TYPL = ifelse(is.na(TYPL), "Unknown", TYPL),
      TYPMR = ifelse(is.na(TYPMR), "Unknown", TYPMR),
      VOIT = ifelse(is.na(VOIT), "Unknown", VOIT)
    )
}

# Check missing values summary after cleaning
summary_missing_cleaned <- mob_pro_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

### Handling missing values of var_mob_pro (var_mob_pro_cleaned)

```{r}
# Investigate rows with missing values
missing_var_mob_pro <- var_mob_pro %>%
  filter(is.na(COD_MOD) | is.na(LIB_MOD))

# Print rows with missing values for inspection
print("Rows with missing values in var_mob_pro:")
print(missing_var_mob_pro)

# We'll impute missing values with "Unknown"
var_mob_pro_cleaned <- var_mob_pro %>%
  mutate(
    COD_MOD = ifelse(is.na(COD_MOD), "Unknown", COD_MOD),
    LIB_MOD = ifelse(is.na(LIB_MOD), "Unknown", LIB_MOD)
  )

# Check for missing values after cleaning
summary_missing_cleaned <- var_mob_pro_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print("Missing values summary after cleaning:")
print(summary_missing_cleaned)

```

## Creating consistent variable names

```{r}
# Load janitor package
library(janitor)

# List of datasets to clean
datasets <- list(
  demo = demo_cleaned,
  iltduu_sexe_trans = iltduu_sexe_trans,
  local_mob = local_mob_cleaned,
  revenus = revenus_cleaned,
  stops_france = stops_france_cleaned,
  mob_pro = mob_pro_cleaned,
  var_mob_pro = var_mob_pro_cleaned
)

# Apply janitor::clean_names() to each dataset
datasets_cleaned <- lapply(datasets, clean_names)

# Extract cleaned datasets back into individual variables
demo_cleaned <- datasets_cleaned$demo
iltduu_sexe_trans_cleaned <- datasets_cleaned$iltduu_sexe_trans
local_mob_cleaned <- datasets_cleaned$local_mob
revenus_cleaned <- datasets_cleaned$revenus
stops_france_cleaned <- datasets_cleaned$stops_france
mob_pro_cleaned <- datasets_cleaned$mob_pro
var_mob_pro_cleaned <- datasets_cleaned$var_mob_pro

# Compare variable names across datasets
variable_names <- lapply(datasets_cleaned, names)
print("Variable names in each dataset:")
print(variable_names)

# Rename variables in demo_cleaned
demo_cleaned <- demo_cleaned %>%
 rename(
  intercommunal_label = x2,
  municipal_population_2021 = x3,
  population_density_2021 = x4,
  intercommunal_code = insee_statistiques_locales
 )

# Rename variables in local_mob_cleaned
local_mob_cleaned <- local_mob_cleaned %>%
  rename(
   communal_label = x2,
   share_worker_public_transport = x3,
   share_household_car = x4,
   share_car_for_work = x5,
   share_bike_for_work = x6,
   communal_code = insee_statistiques_locales
  )

# Rename variables in revenus_cleaned
revenus_cleaned <- revenus_cleaned %>%
  rename(
   communal_code = insee_statistiques_locales,
   communal_label = x2,
   number_household_2021 = x3,
   median_living_standard_2021 = x4,
  )

# Rename variables in mob_pro_cleaned
mob_pro_cleaned <- mob_pro_cleaned %>%
  rename(
    communal_code = commune, # communal code for place of residency
    residency_district = arm, # districts (arrondissement) of residency are just for paris, lyon, marseille (if not, just       ZZZZZ)
    workplace_abroad_communal_code = dcflt, # if working abroad only (99999 if working in France, ZZZZZ if not applicable).       AL for Germany, BE for Belgium, LU for Luxembourg, SU for Swtizerland
    workplace_communal_code = dclt,
    age_five_year_slice = agerevq, # five year age in completed years (by slices of 5, from 000 - 0 to 4yo to 120 - 120 yo)
    socio_professional_cat = cs1, # 8 types of socio professional categories (1 through 8)
    nb_household_two_wheelers = derou, # 0 to 3, with 3 being 3 and more, U is for "hors logement ordinaire                 (DOM/métropolitaine", X is "logement ordinaire innocupé (DOM)", Z is for "logement ordinaire (métropolitaine)
    highest_qualification = dipl, # from 01 (nothing) to 19 (non medical PhD), ZZ are for not applicable (less than 14yo)
    employment_condition = empl, # from 11 (apprenticeship) to 23 (familial aide), with ZZ for without object
    workplace_indicator = ilt, # from 1 (in residency commune) to 7 (abroad), Z is without object
    urban_workplace_indicator = iltuu, # from 1 (works in rural residency commune) to 5 (works away from urban residency         commune), Z is without object
    immigration_status = immi, # 1 is immigrant, 2 is non immigrant
    nationality = inatc, # 1 is French, 2 is non french
    nb_students_trainee_over_14_household = ineem, # number, Y means hors résidence principale, Z means hors logement ordinaire
    nb_employed_people_household = inpom, # number, Y and Z means the same as above
    nb_scolarised_people_household = inpsm, # number, Y and Z means the same as above
    weight = ipondi, # in decimal weight
    link_household_reference_person = lprm, # from 1 (reference person of the household) to 9 (housemaid living in household), Z meaning "hors logement ordinaire"
    metrodom_indicator = metrodom, # M for metropolitan france, D for DOM
    cohabitation_mode = moco, # 8 types defined by a number (for example: 11 is children from couple)
    economic_activity = na5, # 5 types of role depending on the field (example: FZ is construction), ZZ is without object
    number_people_household = nperr, # from 1 to 6 (6 being 6 or more), Z is for hors logement ordinaire
    region_residency = region, 
    region_workplace = reglt, ## 99 for abroad, ZZ for outre-mer, YY for without object
    sexe = sexe, # 1 is for male (of course) and 2 for female
    professional_status = stat, # 4 categories (for example 10 is salaried employee), ZZ is without object
    occupancy_status_accomodation = stocd, # 6 types (for example 10 is landlord), ZZ is hors logement ordinaire
    working_time = tp, # 1 for full time, 2 for part time employment, Z for without object
    main_transportation_work = trans, # 6 types (for example 1 is no transport), Z is without object
    accomodation_type = typl, # 6 types (for ex 1 is house) Z is without object
    type_of_household = typmr, # 9 types (for ex 11 is a man living alone), ZZ for hors logement ordinaire
    number_car_household = voit # 0 to 3 (3 being 3 cars or more), X for logement ordinaire innocupé, Z for hors logement ordinaire
  )

# Rename variables in iltduu_sexe_trans_cleaned
iltduu_sexe_trans_cleaned <- iltduu_sexe_trans_cleaned %>%
  rename(
   sexe = sexe,
   main_transportation_work = trans_19,
   urban_workplace_indicator = iltduu,
   communal_code = codgeo,
   communal_label = libgeo,
   geographical_type = nivgeo
   # We have to look at what nivgeo and nb are more specifically before renaming them. 
  )

# Verify the renamed variables
list(
  demo_cleaned = names(demo_cleaned),
  local_mob_cleaned = names(local_mob_cleaned),
  revenus_cleaned = names(revenus_cleaned)
)
```

**WE NEED TO DO SOME MORE DIGGING FOR MOB_PRO_CLEANED (see if some variable names
should be the same as for other datasets), but the data set is so big
to visualize :( need to spend some time on this specifically!**

## Removing the descriptive meta data

```{r}
# Remove first two rows for demo_cleaned, local_mob_cleaned, and revenus_cleaned
demo_cleaned <- demo_cleaned[-c(1, 2), ]
local_mob_cleaned <- local_mob_cleaned[-c(1, 2), ]
revenus_cleaned <- revenus_cleaned[-c(1, 2), ]

# Preview the updated datasets
head(demo_cleaned)
head(local_mob_cleaned)
head(revenus_cleaned)
```

## Removing the columns we won't need in mob_pro_cleaned

There are way too many variables in mob_pro_cleaned (32), surely we should not need all of them to conduct our analysis:
```{r}
library(dplyr)

# If we just want to specify the ones we want to keep:
#mob_pro_cleaned <- mob_pro_cleaned %>%
  #select(column_name_1, column_name_2, column_name_4) # Replace with the names of the columns you want to keep

# If we want to specify the ones we want to remove:
mob_pro_cleaned <- mob_pro_cleaned %>%
  select(-immigration_status, -nationality, -nb_students_trainee_over_14_household, -weight, -link_household_reference_person, -cohabitation_mode, -nb_employed_people_household, -nb_scolarised_people_household, - residency_district) # Replace with the actual column names

colnames(mob_pro_cleaned)
```


## Validating each data type

```{r}
# Validate and adjust data types for demo_cleaned
str(demo_cleaned)  # Check current types
demo_cleaned <- demo_cleaned %>%
  mutate(
    intercommunal_code = as.character(intercommunal_code),
    intercommunal_label = as.character(intercommunal_label),
    municipal_population_2021 = as.numeric(municipal_population_2021),
    population_density_2021 = as.numeric(population_density_2021)
  )

# Validate and adjust data types for local_mob_cleaned
str(local_mob_cleaned)
local_mob_cleaned <- local_mob_cleaned %>%
  mutate(
    communal_code = as.character(communal_code),
    communal_label = as.character(communal_label),
    share_worker_public_transport = as.numeric(share_worker_public_transport),
    share_household_car = as.numeric(share_household_car),
    share_car_for_work = as.numeric(share_car_for_work),
    share_bike_for_work = as.numeric(share_bike_for_work)
  )

# Validate and adjust data types for revenus_cleaned
str(revenus_cleaned)
revenus_cleaned <- revenus_cleaned %>%
  mutate(
    communal_code = as.character(communal_code),
    communal_label = as.character(communal_label),
    number_household_2021 = as.numeric(number_household_2021),
    median_living_standard_2021 = as.numeric(median_living_standard_2021)
  )

# Validate and adjust data types for iltduu_sexe_trans_cleaned
str(iltduu_sexe_trans)
iltduu_sexe_trans_cleaned <- iltduu_sexe_trans_cleaned %>%
  mutate(
    geographical_type = as.factor(geographical_type),
    communal_code = as.character(communal_code),
    communal_label = as.character(communal_label),
    sexe = as.factor(sexe),
    main_transportation_work = as.factor(main_transportation_work),
    nb = as.numeric(nb),
    urban_workplace_indicator = as.factor(urban_workplace_indicator)
  )


# Validate and adjust data types for stops_france_cleaned
str(stops_france)
stops_france <- stops_france %>%
  mutate(
    dataset_custom_title = as.character(dataset_custom_title),
    stop_name = as.character(stop_name),
    stop_lat = as.numeric(stop_lat),
    stop_lon = as.numeric(stop_lon)
  )

# Validate and adjust data types for mob_pro_cleaned
str(mob_pro)
mob_pro_cleaned <- mob_pro_cleaned %>%
  mutate(
    communal_code = as.character(communal_code),
    workplace_abroad_communal_code = as.character(workplace_abroad_communal_code),
    workplace_communal_code = as.character(workplace_communal_code),
    age_five_year_slice = as.factor(age_five_year_slice),
    socio_professional_cat = as.factor(socio_professional_cat),
    nb_household_two_wheelers = as.numeric(nb_household_two_wheelers),
    highest_qualification = as.factor(highest_qualification),
    employment_condition = as.factor(employment_condition),
    workplace_indicator = as.factor(workplace_indicator),
    urban_workplace_indicator = as.factor(urban_workplace_indicator),
    metrodom_indicator = as.factor(metrodom_indicator),
    economic_activity = as.factor(economic_activity),
    number_people_household = as.numeric(number_people_household),
    region_residency = as.character(region_residency),
    region_workplace = as.character(region_workplace),
    sexe = as.factor(sexe),
    professional_status = as.factor(professional_status),
    occupancy_status_accomodation = as.factor(occupancy_status_accomodation),
    working_time = as.factor(working_time),
    main_transportation_work = as.factor(main_transportation_work),
    accomodation_type = as.factor(accomodation_type),
    type_of_household = as.factor (type_of_household),
    number_car_household = as.numeric(number_car_household)
  )

# Validate and adjust data types for var_mob_pro_cleaned
str(var_mob_pro)
var_mob_pro_cleaned <- var_mob_pro_cleaned %>%
  mutate(
    cod_var = as.character(cod_var),
    lib_var = as.character(lib_var),
    cod_mod = as.character(cod_mod),
    lib_mod = as.character(lib_mod),
    type_var = as.character(type_var),
    long_var = as.character(long_var)
  )

# Revalidate all datasets
list(
  demo_cleaned = str(demo_cleaned),
  local_mob_cleaned = str(local_mob_cleaned),
  revenus_cleaned = str(revenus_cleaned),
  iltduu_sexe_trans_cleaned = str(iltduu_sexe_trans),
  stops_france_cleaned = str(stops_france),
  mob_pro_cleaned = str(mob_pro),
  var_mob_pro_cleaned = str(var_mob_pro)
)
```

## Creating consistent observation names / give labels to factors for easier identification

```{r}

```

## Removing duplicates

```{r}
library(dplyr)

# Store initial row counts
initial_rows <- sapply(list(
  stops_france_cleaned
), nrow)

# Stops France dataset
stops_france_cleaned <- stops_france_cleaned %>% 
  distinct()
cat("Stops France: Removed", nrow(stops_france) - nrow(stops_france_cleaned), "duplicate rows.\n")

# Store final row counts
final_rows <- sapply(list(
  stops_france_cleaned
), nrow)

# Summarize row changes
datasets <- c("Stops France")
row_summary <- data.frame(
  Dataset = datasets,
  Initial_Rows = initial_rows,
  Final_Rows = final_rows,
  Duplicates_Removed = initial_rows - final_rows
)

# Print the summary
print(row_summary)
```

## Filtering and selecting relevant columns

```{r}

```


# Data Joining

