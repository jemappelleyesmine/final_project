---
title: "The Drivers of Commuter Behavior in France"
author: "Mathilde VALLAT, Yesmine HACHANA"
format: pdf
editor: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
# Load knitr package
library(knitr)

# Set global chunk options
knitr::opts_chunk$set(
  echo = FALSE,    # Hide all code
  message = FALSE, # Suppress messages
  warning = FALSE  # Suppress warnings
)
```

# Table of Contents

1.  [Introduction](#introduction)
2.  [Research Question](#research-question)
3.  [Datasets](#datasets)
4.  [Data Cleaning](#data-cleaning)
5.  [Data Joining](#data-joining)
6.  [Cleaning the Join](#cleaning-the-join)
7.  [First Exploratory Analysis](#first-exploratory-analysis)
8.  [Data Analysis](#data-analysis)
9.  [Discussion](#discussion)

[Link to the github
projec](https://github.com/jemappelleyesmine/final_project)

# Introduction {#introduction}

#### **Context and Relevance**

-   **Background on Commuting Behavior:**

    -   Commuting is a daily activity that affects millions of people in
        France and globally.

    -   The mode of transport chosen has a significant impact on energy
        consumption, urban planning, and the environment.

-   **Why this Question Matters:**

    -   Identifying the key factors influencing transport choices can
        help policymakers target interventions effectively.

    -   Understanding socio-economic, demographic, and infrastructural
        drivers of commuting behaviors can guide investment in
        sustainable transport systems.

    -   Insights into these factors can promote equity in transportation
        access, ensuring rural and low-income populations are not left
        behind.

-   **Link to Climate Change:**

    -   Transportation accounts for a significant share of global
        greenhouse gas (GHG) emissions, with private vehicles being a
        major contributor.

    -   Shifting commuters from high-carbon modes like cars to
        lower-carbon options like public transport, cycling, or walking
        is essential for meeting climate goals such as those outlined in
        the Paris Agreement.

    -   France has committed to reducing its carbon footprint, and
        understanding commuter behavior is vital for designing effective
        policies to encourage sustainable transportation choices.

-   **Broader Impacts:**

    -   Beyond climate change, transport choices affect public health
        (e.g., air quality, physical activity) and quality of life
        (e.g., time spent commuting, stress levels).

    -   Aligning commuter preferences with sustainable goals can create
        co-benefits, such as improved urban mobility, reduced traffic
        congestion, and healthier lifestyles.

-   **Importance of the Study:**

    -   **For Policymakers:**

        -   Results can guide targeted investments in public transport
            and cycling infrastructure.

        -   Policies can be tailored to different socio-economic groups
            and geographic contexts to maximize impact.

    -   **For Society:**

        -   Promoting sustainable transport can contribute to lower
            emissions, improved health outcomes, and more equitable
            access to mobility.

    -   **For Research:**

        -   Adds to the growing body of literature on transport
            behavior, with a specific focus on France, offering insights
            that may be applicable to other countries with similar
            challenges.

# Research question {#research-question}

Our research question is: “What are the drivers influencing commuter
choices in France?” Understanding what influences individuals’ commuting
choices in France can provide insights into environmental policy and
urban planning. Commuter behavior reflects socio-economic, geographic,
and infrastructural factors, which shape transportation systems, urban
development, and sustainability efforts. This project seeks to explore
possible key drivers of commuter choices, with a focus on big datasets
with different levels of aggregation. We chose to investigate several
factors influencing commuter behavior based on the availability of
datasets and the type of information that could be publicly available.

Here are some factors that we have thought of:

-   **Type of Area (Urban or Rural)**: Commuting options and preferences
    may differ between urban and rural areas due to infrastructure
    availability, population density, and economic activity.

-   **Socio-Professional Category and Income Levels**: Professional
    status and income levels might play a role in transportation choices
    (affordability, accessibility).

-   **Population Density**: Denser areas may encourage the use of public
    transit and non-motorized options, while less dense regions may rely
    more heavily on private vehicles.

-   **Commuting Distance**: The length of the commute is an important
    variable, as it could dictate whether an individual opts for
    walking, cycling, driving, or public transit.

-   **Accessibility to Transportation Infrastructure**: The availability
    of public transit could affect convenience and practicality.

Our project involves several steps: firstly, we must collect, store, and
organize datasets in a GitHub repository. Since datasets are aggregated
at varying levels (e.g., “commune” vs. “intercommunal” and with
"lon/lat"), we will have to harmonize these differences using data
management methods seen in class. In parallel, we will have to look for
missing or inconsistent data that may complicate our data analysis.
After this, we will start initial data exploration by trying to
summarize variables and visualize relationships using R. At the end, the
goal will be to generate visualizations to identify patterns and
evaluate the influence of each factor on commuter behavior. The biggest
challenge will probably be harmonizing datasets with differing levels of
aggregation, such as municipal and regional data. For now, our
expectations are to successfully manage to clean the data, and find some
drivers of commuter behavior in France and manage to generate clear and
simple ways to visualize and understand those patterns.

# Datasets {#datasets}

## Source Descriptions {#source-descriptions}

This section describes the datasets used in the analysis, including
sources and how the data was selected.

### **INSEE Demographic Data**

INSEE_Statistiques_locales_demographie.csv

-   **Source**: [INSEE Demographic
    Data](https://statistiques-locales.insee.fr/#view=map1&c=indicator)
-   **Key Variables**: Population, Population Density.
-   **Geographical Level**: Intercommunalité.

To reproduce the data selection:

In "CHOISIR DES INDICATEURS", go to DÉMOGRAPHIE, then select:

-   Population municipale (historique depuis 1876) 2021

-   Densité de population (historique depuis 1876) 2021

In "CHANGER LE DÉCOUPAGE GÉOGRAPHIQUE", select:

-   Intercommunalité-Métropole

### INSEE Income Data

INSEE_Statistiques_locales_menages_fiscaux_niveau_de_vie.csv

-   **Source**: [INSEE Income
    Data](https://statistiques-locales.insee.fr/#view=map1&c=indicator)
-   **Key Variables**: Median Income, Number of Households.
-   **Geographical Level**: Commune.

To reproduce the data selection:

In "CHOISIR DES INDICATEURS", go to REVENUS - POUVOIR D'ACHAT -
CONSOMMATION, then select:

-   Nb de ménages fiscaux 2021

-   Médiane du niveau de vie 2021

In "CHANGER LE DÉCOUPAGE GÉOGRAPHIQUE", select:

-   Commune

### INSEE Commuter Data

INSEE_Statistiques_locales_territoires_ville_quartiers.csv

-   **Source**: [INSEE Commuter
    Data](https://statistiques-locales.insee.fr/#view=map1&c=indicator)
-   **Key Variables**: Number of housholds owning a car, Use of types of
    transportation
-   **Geographical Level**: Commune.

To reproduce the data selection:

In "CHOISIR DES INDICATEURS", go to TERRITOIRES, VILLES ET QUARTIERS,
then select:

-   Part des actifs occupés de 15 ans ou plus les transports en commun
    2021

-   Part des ménages ayant au moins 1 voiture 2021

-   Part des actifs occ 15 ans ou plus voiture pour travailler 2021

-   Part des actifs occ 15 ans ou plus vélo pour travailler 2021

In "CHANGER LE DÉCOUPAGE GÉOGRAPHIQUE", select:

-   Commune

### Experimental Dataset: Public Transport Stops

stops_france.csv.gz

-   **Source**:
    [transport.data.gouv.fr](https://transport.data.gouv.fr/datasets/arrets-de-transport-en-france)
-   **Key Variables**: Stop Name, Location (Lat/Lon).

### INSEE MOB PRO

RP2021_mobpro.zip

-   **Source**: [INSEE MOB
    PRO](https://www.insee.fr/fr/statistiques/8205896?sommaire=8205966)

### INSEE MOB TRANS

BTT_TD_NAV2B_2017.zip

-   **Source**: [INSEE MOB
    TRANS](https://www.insee.fr/fr/statistiques/4515510?sommaire=4516095&q=mobilite+et+transports#consulter)

To reproduce the data selection:

-   "NAV2B – Population active de 15 ans ou plus ayant un emploi par
    sexe, lieu de travail (géographie urbaine) et moyen de transport"

### Loading Datasets

-   Loading stops_france

```{r}
library(vroom)
library(here)
here::i_am("Final_Project_Commuter_behavior.Rproj")

source <- "https://www.data.gouv.fr/fr/datasets/r/69cf54c6-6591-4920-b1d6-2a5292964606"
local_name <- "stops_france.csv.gz"
local_dir <- "data"
## is the directory available?
if (!dir.exists(here(local_dir))) {
  ## create the directory if needed
  dir.create(here(local_dir))
}
## is the file available?
if (!file.exists(here(local_dir, local_name))) {
  ## we need to download it
  stops_france <- vroom(source)
  ## let's save the file to avoid useless downloading
  vroom_write(stops_france, here(local_dir, local_name), delim = ",")
} else {
  ## we need only to load it
  stops_france <- vroom(here(local_dir, local_name))
}
```

-   Loading mob_pro

```{r}
library(zip)
# Define variables
source <- "https://www.insee.fr/fr/statistiques/fichier/8205896/RP2021_mobpro.zip"
local_name <- "RP2021_mobpro.zip"
local_dir <- "data"
csv1_name <- "FD_MOBPRO_2021.csv"
csv2_name <- "varmod_mobpro_2021.csv"
# Check if the directory exists, create if not
if (!dir.exists(here(local_dir))) {
  dir.create(here(local_dir))
}
# Check if the ZIP file exists locally
if (!file.exists(here(local_dir, local_name))) {
  # Download the ZIP file
  download.file(source, destfile = here(local_dir, local_name), mode = "wb")
}
# Unzip the file
unzip(here(local_dir, local_name), exdir = here(local_dir))
# Load the first CSV file
mob_pro <- vroom(here(local_dir, csv1_name))
# Load the second CSV file
var_mob_pro <- vroom(here(local_dir, csv2_name))
```

-   Loading iltduu_sexe_trans

```{r}
# Define variables
source <- "https://www.insee.fr/fr/statistiques/fichier/4515510/BTT_TD_NAV2B_2017.zip"
local_name <- "BTT_TD_NAV2B_2017.zip"
local_dir <- "data"
csv_name <- "BTT_TD_NAV2B_2017.CSV"
# Check if the directory exists, create it if not
if (!dir.exists(here(local_dir))) {
  dir.create(here(local_dir))
}
# Check if the ZIP file exists locally
if (!file.exists(here(local_dir, local_name))) {
  # Download the ZIP file
  download.file(source, destfile = here(local_dir, local_name), mode = "wb")
}
# Unzip the file
unzip(here(local_dir, local_name), exdir = here(local_dir))
# Load the specified CSV file
iltduu_sexe_trans <- vroom(here(local_dir, csv_name))
```

-   Loading the local files

```{r}
demo <- vroom(here("data", "INSEE_Statistiques_locales_demographie.csv"))
revenus <- vroom(here("data","INSEE_Statistiques_locales_menages_fiscaux_niveau_de_vie.csv"))
local_mob <- vroom(here("data","INSEE_Statistiques_locales_territoires_ville_quartiers.csv"))
```

### Description of the sources

Our first source is the “Statistiques Locales” platform by INSEE. This
platform provides geolocalized data to analyze territorial / spatial
phenomena in France. It is an online tool that can allow us to have
access to statistical information (which are categorized by geographic
areas) through tables . Most importantly for us, it offers datasets on
urban and travel indicators. There are three datasets from this platform
which we are interested in: The data tab called “Territoires, villes et
quartiers” (especially its sub-tab “Mobilités - Déplacements”). The data
tab called “Démographie” (notably its data on population density by
geography). The data tab called “Développement Durable - Environnement”,
which provides a data set on the median standard of living in France by
geographical area (“commune”).

Our second source is an experimental dataset published on the
governmental website transport.data.gouv.fr by the “Ministère du
partenariat avec les territoires et de la décentralisation”. This
platform provides a dataset of public transport stop points across
France. This dataset aggregates GTFS (General Transit Feed
Specification) data collected from the National Access Point for
transport data. It includes the name, coordinates (longitude and
latitude), region, mobility authority (if applicable), and GTFS
identifiers of each stop. The data set has limitations such as
duplication of stops.

Our third source is INSEE's December 2020 dataset on commuting patterns
from the 2017 population census. This dataset, titled NAV2B, focuses on
employed individuals aged 15 and older, sharing their means of
transportation for commuting to work, disaggregated by gender and
workplace geography (urban vs. rural). It provides granular data at the
municipal level for all French communes except Mayotte.

Our final source is an INSEE 2024 dataset on professional mobility, from
the 2021 population It contains data linking individuals' places of
residence and work at the municipal level, including cross-border
commuting. It provides information on individuals aged 15 and older who
are employed, with variables describing their household, primary
residence, and commuting patterns.

```{r}
# Load required libraries
library(tibble)
library(knitr)

# Define datasets
datasets <- list(
  iltduu_sexe_trans = iltduu_sexe_trans,
  stops_france = stops_france,
  mob_pro = mob_pro,
  var_mob_pro = var_mob_pro,
  revenus = revenus,
  demo = demo,
  local_mob = local_mob
)

# Generate a table for each dataset
for (name in names(datasets)) {
  # Access the dataset
  data <- datasets[[name]]
  # Compute basic information
  summary_table <- tibble(
    Statistic = c(
      "Number of Rows",
      "Number of Columns"
    ),
    Value = c(
      nrow(data),
      ncol(data)
    )
  )

  # Print a heading and the table
cat("\n### Summary Table for Dataset:", name, "\n")
print(
  kable(summary_table, format = "pipe", caption = paste("Summary Table for Dataset:", name))
)
cat("\n")
}
  
```

### Description of the main variables

**Statistiques Locales Platform by INSEE**

-   "Territoires, villes et quartiers" data tab

*“Part des actifs occupés de 15 ans ou plus qui utilisent principalement
les transports en commun pour aller travailler”*:

This variable represents the proportion of employed individuals aged 15
and older who primarily rely on public transportation for commuting to
work in 2021. It is categorized by commune.

-   "Démographie" data tab

*"Densité de population":*

This variable represents the population density, calculated as the
number of inhabitants (municipal count) per square kilometer, for each
intercommunal area, since 1876.

-   "Développement durable - Environnement" data tab

*"Médiane du niveau de vie"*:

This variable represents, across communes, the median disposable income
per household, calculated by dividing the household's total disposable
income by the number of consumption units. It excludes small zones with
fewer than 50 households or 100 individuals for statistical
confidentiality.

**Experimental dataset from transport.data.gouv.fr**

*"stop_name":*

This variable represents the name of a public transportation stop, as
listed in the experimental dataset from transport.data.gouv.fr. Each
stop is geolocated using its latitude and longitude. The dataset
aggregates stops from multiple GTFS files, and the stop names are not
deduplicated, meaning multiple entries can correspond to the same
physical stop across different datasets.

**INSEE's December 2020 NAV2B data set**

*“TRANS_19”* :

This variable categorizes the primary mode of transportation used by
employed individuals aged 15 years and above for commuting, by commune.
The modes include walking, cycling, public transport, private vehicles
(car, van, truck), motorized two-wheelers, and no transportation (e.g.,
work from home).

*“ILTDUU”*:

This variable categorizes the commuting pattern of individuals based on
the urban or rural classification of their residence and workplace. The
categories include living and working in the same rural or urban
commune, commuting from a rural area to another rural or urban commune,
or commuting from an urban area to other urban or rural locations.

**INSEE's 2024 dataset on professional mobility**

*"DEROU":*

This variable represents the number of motorized two-wheelers (such as
motorcycles or scooters) owned by the household.

*"DIPL":*

This variable indicates the highest level of educational qualification
achieved by an individual.

*"INPOM":*

This variable provides the count of employed individuals within a
household.

*"VOIT":*

This variable represents the number of cars owned by the household.

*"COMMUNE":*

Refers to the municipality or town of residence or work.

*"ILT":*

Indicates the location of an individual's workplace relative to their
residence, categorized into five groups: within the same municipality, a
different municipality in the same department, another department in the
same region, another region in metropolitan France, or outside
metropolitan France (including overseas or abroad).

### Graphical representation of one of the main variables

```{r}
# Load libraries
library(dplyr)
library(ggplot2)
```

```{r}
# Remove rows where nb is na
iltduu_sexe_trans <- iltduu_sexe_trans %>%
  filter(!is.na(NB))
```

```{r}
# checking there are no missing values there
any(is.na(iltduu_sexe_trans$NB))
```

```{r}
library(dplyr)
library(ggplot2)
library(scales) # formatting the numbers :)

# Summarizing our data to get counts for each transport mode
trans_19_summary <- iltduu_sexe_trans %>%
  group_by(TRANS_19) %>%
  summarise(Count = sum(NB)) # Sum the NB column for each transport mode

# Mapping the transport modes to their labels
trans_19_summary$Mode <- factor(trans_19_summary$TRANS_19,
  levels = 1:6,
  labels = c("No Transport", "Walking", "Bicycle", "Motorized Two-Wheelers", "Car/Truck/Van", "Public Transport")
)

# Creating the graphical representation (after everything)
ggplot(trans_19_summary, aes(x = Mode, y = Count, fill = Mode)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(
    title = "Distribution of Transport Modes (TRANS_19)",
    x = "Mode of Transport",
    y = "Count of Individuals"
  ) +
  scale_y_continuous(labels = label_comma()) + # Format y-axis labels
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

# Data Cleaning {#data-cleaning}

### Checking for missing values

```{r}
library(dplyr)
library(tidyr)

# Create a function to summarize missing values
summarize_missing <- function(dataset) {
  missing_summary <- dataset %>%
    summarise(across(everything(), ~ sum(is.na(.)))) %>%
    pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")
  
  return(missing_summary)
}

# Apply the function to each dataset
datasets <- list(
  demo = demo,
  iltduu_sexe_trans = iltduu_sexe_trans,
  local_mob = local_mob,
  revenus = revenus,
  stops_france = stops_france,
  mob_pro = mob_pro,
  var_mob_pro = var_mob_pro
)

missing_values_summary <- lapply(datasets, summarize_missing)

# Print summary for each dataset
for (name in names(missing_values_summary)) {
  cat("\n### Missing Value Summary for Dataset:", name, "\n")
  print(missing_values_summary[[name]])
}
```

**Handling missing values of demo (demo_cleaned)**

```{r}
library(dplyr)

# Handle missing values in 'demo'
demo_cleaned <- demo %>%
  # Replace missing values in columns (impute with placeholder "Unknown")
  mutate(
    `...2` = ifelse(is.na(`...2`), "Unknown", `...2`),
    `...3` = ifelse(is.na(`...3`), "Unknown", `...3`),
    `...4` = ifelse(is.na(`...4`), "Unknown", `...4`)
  )

# Check to confirm no missing values remain
summary_missing_cleaned <- demo_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

**Handling missing values of local_mob (local_mob_cleaned)**

```{r}
# Handling missing values in local_mob
local_mob_cleaned <- local_mob %>%
  mutate(
    # Replace missing values in categorical columns with "Unknown"
    `Insee - Statistiques locales` = ifelse(is.na(`Insee - Statistiques locales`), "Unknown", `Insee - Statistiques locales`),
    `...2` = ifelse(is.na(`...2`), "Unknown", `...2`),
    
    # Replace missing values in numeric columns with the column mean
    `...3` = ifelse(is.na(`...3`), mean(as.numeric(`...3`), na.rm = TRUE), `...3`),
    `...4` = ifelse(is.na(`...4`), mean(as.numeric(`...4`), na.rm = TRUE), `...4`),
    `...5` = ifelse(is.na(`...5`), mean(as.numeric(`...5`), na.rm = TRUE), `...5`),
    `...6` = ifelse(is.na(`...6`), mean(as.numeric(`...6`), na.rm = TRUE), `...6`)
  )

# Check to confirm no missing values remain
summary_missing_cleaned <- local_mob_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

**Handling missing values of revenus (revenus_cleaned)**

```{r}
# Handling missing values in the revenus dataset
revenus_cleaned <- revenus %>%
  mutate(
    `...2` = ifelse(is.na(`...2`), "Unknown", `...2`),
    `...3` = ifelse(is.na(`...3`), round(mean(as.numeric(`...3`), na.rm = TRUE)), `...3`),
    `...4` = ifelse(is.na(`...4`), median(as.numeric(`...4`), na.rm = TRUE), `...4`)
  )

# Check to confirm no missing values remain
summary_missing_cleaned <- revenus_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

**Handling missing values of stops_france (stops_france_cleaned)**

```{r}
# Handling missing values and removing unnecessary columns in stops_france
stops_france_cleaned <- stops_france %>%
  select(-dataset_aom_id, -dataset_region_id) %>% # Remove columns with excessive missing values
  mutate(
    dataset_organisation = ifelse(is.na(dataset_organisation), "Unknown", dataset_organisation),
    stop_name = ifelse(is.na(stop_name), "Unnamed Stop", stop_name)
  )

# Check to confirm no missing values remain
summary_missing_cleaned <- stops_france_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

**Handling missing values of mob_pro (mob_pro_cleaned)**

```{r}
# Investigate rows with missing values
missing_rows <- mob_pro %>%
  filter(is.na(INEEM) & is.na(INPOM) & is.na(INPSM) & is.na(LPRM) & 
         is.na(NPERR) & is.na(STOCD) & is.na(TYPL) & is.na(TYPMR) & is.na(VOIT))

# Check the proportion of missing rows
missing_row_count <- nrow(missing_rows)
total_row_count <- nrow(mob_pro)
proportion_missing <- missing_row_count / total_row_count

print(paste("Proportion of rows with all these variables missing:", proportion_missing))

# If the proportion of missing rows is small, remove them
if (proportion_missing < 0.05) { # Adjust threshold as necessary
  mob_pro_cleaned <- mob_pro %>%
    filter(!(is.na(INEEM) & is.na(INPOM) & is.na(INPSM) & is.na(LPRM) & 
             is.na(NPERR) & is.na(STOCD) & is.na(TYPL) & is.na(TYPMR) & is.na(VOIT)))
} else {
  # Otherwise, impute the missing values
  mob_pro_cleaned <- mob_pro %>%
    mutate(
      INEEM = ifelse(is.na(INEEM), "Unknown", INEEM),
      INPOM = ifelse(is.na(INPOM), "Unknown", INPOM),
      INPSM = ifelse(is.na(INPSM), "Unknown", INPSM),
      LPRM = ifelse(is.na(LPRM), "Unknown", LPRM),
      NPERR = ifelse(is.na(NPERR), "Unknown", NPERR),
      STOCD = ifelse(is.na(STOCD), "Unknown", STOCD),
      TYPL = ifelse(is.na(TYPL), "Unknown", TYPL),
      TYPMR = ifelse(is.na(TYPMR), "Unknown", TYPMR),
      VOIT = ifelse(is.na(VOIT), "Unknown", VOIT)
    )
}

# Check missing values summary after cleaning
summary_missing_cleaned <- mob_pro_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print(summary_missing_cleaned)
```

**Handling missing values of var_mob_pro (var_mob_pro_cleaned)**

```{r}
# Investigate rows with missing values
missing_var_mob_pro <- var_mob_pro %>%
  filter(is.na(COD_MOD) | is.na(LIB_MOD))

# Print rows with missing values for inspection
print("Rows with missing values in var_mob_pro:")
print(missing_var_mob_pro)

# We'll impute missing values with "Unknown"
var_mob_pro_cleaned <- var_mob_pro %>%
  mutate(
    COD_MOD = ifelse(is.na(COD_MOD), "Unknown", COD_MOD),
    LIB_MOD = ifelse(is.na(LIB_MOD), "Unknown", LIB_MOD)
  )

# Check for missing values after cleaning
summary_missing_cleaned <- var_mob_pro_cleaned %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

# Print cleaned dataset summary
print("Missing values summary after cleaning:")
print(summary_missing_cleaned)

```

### Creating consistent variable names

```{r}
# Load janitor package
library(janitor)

# List of datasets to clean
datasets <- list(
  demo = demo_cleaned,
  iltduu_sexe_trans = iltduu_sexe_trans,
  local_mob = local_mob_cleaned,
  revenus = revenus_cleaned,
  stops_france = stops_france_cleaned,
  mob_pro = mob_pro_cleaned,
  var_mob_pro = var_mob_pro_cleaned
)

# Apply janitor::clean_names() to each dataset
datasets_cleaned <- lapply(datasets, clean_names)

# Extract cleaned datasets back into individual variables
demo_cleaned <- datasets_cleaned$demo
iltduu_sexe_trans_cleaned <- datasets_cleaned$iltduu_sexe_trans
local_mob_cleaned <- datasets_cleaned$local_mob
revenus_cleaned <- datasets_cleaned$revenus
stops_france_cleaned <- datasets_cleaned$stops_france
mob_pro_cleaned <- datasets_cleaned$mob_pro
var_mob_pro_cleaned <- datasets_cleaned$var_mob_pro

# Compare variable names across datasets
variable_names <- lapply(datasets_cleaned, names)
print("Variable names in each dataset:")
print(variable_names)

# Rename variables in demo_cleaned
demo_cleaned <- demo_cleaned %>%
 rename(
  intercommunal_label = x2,
  municipal_population_2021 = x3,
  population_density_2021 = x4,
  intercommunal_code = insee_statistiques_locales
 )

# Rename variables in local_mob_cleaned
local_mob_cleaned <- local_mob_cleaned %>%
  rename(
   communal_label = x2,
   share_worker_public_transport = x3,
   share_household_car = x4,
   share_car_for_work = x5,
   share_bike_for_work = x6,
   communal_code = insee_statistiques_locales
  )

# Rename variables in revenus_cleaned
revenus_cleaned <- revenus_cleaned %>%
  rename(
   communal_code = insee_statistiques_locales,
   communal_label = x2,
   number_household_2021 = x3,
   median_living_standard_2021 = x4,
  )

# Rename variables in mob_pro_cleaned
mob_pro_cleaned <- mob_pro_cleaned %>%
  rename(
    communal_code = commune, # communal code for place of residency
    residency_district = arm, # districts (arrondissement) of residency are just for paris, lyon, marseille (if not, just       ZZZZZ)
    workplace_abroad_communal_code = dcflt, # if working abroad only (99999 if working in France, ZZZZZ if not applicable).       AL for Germany, BE for Belgium, LU for Luxembourg, SU for Swtizerland
    workplace_communal_code = dclt,
    age_five_year_slice = agerevq, # five year age in completed years (by slices of 5, from 000 - 0 to 4yo to 120 - 120 yo)
    socio_professional_cat = cs1, # 8 types of socio professional categories (1 through 8)
    nb_household_two_wheelers = derou, # 0 to 3, with 3 being 3 and more, U is for "hors logement ordinaire                 (DOM/métropolitaine", X is "logement ordinaire innocupé (DOM)", Z is for "logement ordinaire (métropolitaine)
    highest_qualification = dipl, # from 01 (nothing) to 19 (non medical PhD), ZZ are for not applicable (less than 14yo)
    employment_condition = empl, # from 11 (apprenticeship) to 23 (familial aide), with ZZ for without object
    workplace_indicator = ilt, # from 1 (in residency commune) to 7 (abroad), Z is without object
    urban_workplace_indicator = iltuu, # from 1 (works in rural residency commune) to 5 (works away from urban residency commune), Z is without object
    immigration_status = immi, # 1 is immigrant, 2 is non immigrant
    nationality = inatc, # 1 is French, 2 is non french
    nb_students_trainee_over_14_household = ineem, # number, Y means hors résidence principale, Z means hors logement ordinaire
    nb_employed_people_household = inpom, # number, Y and Z means the same as above
    nb_scolarised_people_household = inpsm, # number, Y and Z means the same as above
    weight = ipondi, # in decimal weight
    link_household_reference_person = lprm, # from 1 (reference person of the household) to 9 (housemaid living in household), Z meaning "hors logement ordinaire"
    metrodom_indicator = metrodom, # M for metropolitan france, D for DOM
    cohabitation_mode = moco, # 8 types defined by a number (for example: 11 is children from couple)
    economic_activity = na5, # 5 types of role depending on the field (example: FZ is construction), ZZ is without object
    number_people_household = nperr, # from 1 to 6 (6 being 6 or more), Z is for hors logement ordinaire
    region_residency = region, 
    region_workplace = reglt, ## 99 for abroad, ZZ for outre-mer, YY for without object
    sexe = sexe, # 1 is for male (of course) and 2 for female
    professional_status = stat, # 4 categories (for example 10 is salaried employee), ZZ is without object
    occupancy_status_accomodation = stocd, # 6 types (for example 10 is landlord), ZZ is hors logement ordinaire
    working_time = tp, # 1 for full time, 2 for part time employment, Z for without object
    main_transportation_work = trans, # 6 types (for example 1 is no transport), Z is without object
    accomodation_type = typl, # 6 types (for ex 1 is house) Z is without object
    type_of_household = typmr, # 9 types (for ex 11 is a man living alone), ZZ for hors logement ordinaire
    number_car_household = voit # 0 to 3 (3 being 3 cars or more), X for logement ordinaire innocupé, Z for hors logement ordinaire
  )

# Rename variables in iltduu_sexe_trans_cleaned
iltduu_sexe_trans_cleaned <- iltduu_sexe_trans_cleaned %>%
  rename(
   sexe = sexe,
   main_transportation_work = trans_19,
   urban_workplace_indicator = iltduu,
   communal_code = codgeo,
   communal_label = libgeo,
   geographical_type = nivgeo
   # We have to look at what nivgeo and nb are more specifically before renaming them. 
  )

# Verify the renamed variables
list(
  demo_cleaned = names(demo_cleaned),
  local_mob_cleaned = names(local_mob_cleaned),
  revenus_cleaned = names(revenus_cleaned)
)
```

### Removing the descriptive meta data

```{r}
# Remove first two rows for demo_cleaned, local_mob_cleaned, and revenus_cleaned
demo_cleaned <- demo_cleaned[-c(1, 2), ]
local_mob_cleaned <- local_mob_cleaned[-c(1, 2), ]
revenus_cleaned <- revenus_cleaned[-c(1, 2), ]

# Preview the updated datasets
head(demo_cleaned)
head(local_mob_cleaned)
head(revenus_cleaned)
```

### Removing irrelevant columns

**In mob_pro_cleaned**

There are way too many variables in mob_pro_cleaned (32), surely we
should not need all of them to conduct our analysis:

```{r}
library(dplyr)

# If we want to specify the ones we want to remove:
mob_pro_cleaned <- mob_pro_cleaned %>%
  select(-immigration_status, -nationality, -nb_students_trainee_over_14_household, -weight, -link_household_reference_person, -cohabitation_mode, -nb_employed_people_household, -nb_scolarised_people_household, - residency_district) 

colnames(mob_pro_cleaned)
```

**In stops_france**

```{r}
# If we just want to specify the ones we want to keep:
stops_france_cleaned <- stops_france_cleaned %>%
  select(dataset_custom_title, dataset_organisation, stop_id, stop_name, stop_lat, stop_lon) 

colnames(stops_france_cleaned)
```

### Validating each data type

```{r}
# Validate and adjust data types for demo_cleaned
str(demo_cleaned)  # Check current types
demo_cleaned <- demo_cleaned %>%
  mutate(
    intercommunal_code = as.character(intercommunal_code),
    intercommunal_label = as.character(intercommunal_label),
    municipal_population_2021 = as.numeric(municipal_population_2021),
    population_density_2021 = as.numeric(population_density_2021)
  )

# Validate and adjust data types for local_mob_cleaned
str(local_mob_cleaned)
local_mob_cleaned <- local_mob_cleaned %>%
  mutate(
    communal_code = as.character(communal_code),
    communal_label = as.character(communal_label),
    share_worker_public_transport = as.numeric(share_worker_public_transport),
    share_household_car = as.numeric(share_household_car),
    share_car_for_work = as.numeric(share_car_for_work),
    share_bike_for_work = as.numeric(share_bike_for_work)
  )

# Validate and adjust data types for revenus_cleaned
str(revenus_cleaned)
revenus_cleaned <- revenus_cleaned %>%
  mutate(
    communal_code = as.character(communal_code),
    communal_label = as.character(communal_label),
    number_household_2021 = as.numeric(number_household_2021),
    median_living_standard_2021 = as.numeric(median_living_standard_2021)
  )

# Validate and adjust data types for iltduu_sexe_trans_cleaned
str(iltduu_sexe_trans)
iltduu_sexe_trans_cleaned <- iltduu_sexe_trans_cleaned %>%
  mutate(
    geographical_type = as.factor(geographical_type),
    communal_code = as.character(communal_code),
    communal_label = as.character(communal_label),
    sexe = as.factor(sexe),
    main_transportation_work = as.factor(main_transportation_work),
    nb = as.numeric(nb),
    urban_workplace_indicator = as.factor(urban_workplace_indicator)
  )


# Validate and adjust data types for stops_france_cleaned
str(stops_france)
stops_france <- stops_france %>%
  mutate(
    dataset_custom_title = as.character(dataset_custom_title),
    dataset_organisation = as.character(dataset_organisation),
    stop_id = as.character(stop_id),
    stop_name = as.character(stop_name),
    stop_lat = as.numeric(stop_lat),
    stop_lon = as.numeric(stop_lon)
  )

# Validate and adjust data types for mob_pro_cleaned
str(mob_pro)
mob_pro_cleaned <- mob_pro_cleaned %>%
  mutate(
    communal_code = as.character(communal_code),
    workplace_abroad_communal_code = as.character(workplace_abroad_communal_code),
    workplace_communal_code = as.character(workplace_communal_code),
    age_five_year_slice = as.factor(age_five_year_slice),
    socio_professional_cat = as.factor(socio_professional_cat),
    nb_household_two_wheelers = as.numeric(nb_household_two_wheelers),
    highest_qualification = as.factor(highest_qualification),
    employment_condition = as.factor(employment_condition),
    workplace_indicator = as.factor(workplace_indicator),
    urban_workplace_indicator = as.factor(urban_workplace_indicator),
    metrodom_indicator = as.factor(metrodom_indicator),
    economic_activity = as.factor(economic_activity),
    number_people_household = as.numeric(number_people_household),
    region_residency = as.character(region_residency),
    region_workplace = as.character(region_workplace),
    sexe = as.factor(sexe),
    professional_status = as.factor(professional_status),
    occupancy_status_accomodation = as.factor(occupancy_status_accomodation),
    working_time = as.factor(working_time),
    main_transportation_work = as.factor(main_transportation_work),
    accomodation_type = as.factor(accomodation_type),
    type_of_household = as.factor (type_of_household),
    number_car_household = as.numeric(number_car_household)
  )

# Validate and adjust data types for var_mob_pro_cleaned
str(var_mob_pro)
var_mob_pro_cleaned <- var_mob_pro_cleaned %>%
  mutate(
    cod_var = as.character(cod_var),
    lib_var = as.character(lib_var),
    cod_mod = as.character(cod_mod),
    lib_mod = as.character(lib_mod),
    type_var = as.character(type_var),
    long_var = as.character(long_var)
  )

# Revalidate all datasets
list(
  demo_cleaned = str(demo_cleaned),
  local_mob_cleaned = str(local_mob_cleaned),
  revenus_cleaned = str(revenus_cleaned),
  iltduu_sexe_trans_cleaned = str(iltduu_sexe_trans),
  stops_france_cleaned = str(stops_france),
  mob_pro_cleaned = str(mob_pro),
  var_mob_pro_cleaned = str(var_mob_pro)
)
```

### Give labels to factors for easier identification

**Iltduu Sexe Trans Dataset**

```{r}
iltduu_sexe_trans_cleaned <- iltduu_sexe_trans_cleaned %>%
  mutate(
    geographical_type = factor(
      geographical_type,
      levels = c("COM", "ARM"),
      labels = c("Commune", "Municipal District")
    ),
    sexe = factor(
      sexe,
      levels = c(1, 2),
      labels = c("Male", "Female")
    ),
    main_transportation_work = factor(
      main_transportation_work,
      levels = c(1, 2, 3, 4, 5, 6),
      labels = c(
        "No Transport", "On Foot", "Bicycle", 
        "Motorized Two Wheelers", "Car, Truck, Van", "Public Transport"
      )
    ),
    urban_workplace_indicator = factor(
      urban_workplace_indicator,
      levels = c(1, 2, 3, 4, 5),
      labels = c(
        "Rural: Same Commune", 
        "Rural: Different Commune", 
        "Urban: Same Municipality", 
        "Urban: Same Urban Unit", 
        "Urban: Outside Urban Unit"
      )
    )
  )
```

**Mob Pro Dataset**

```{r}
mob_pro_cleaned <- mob_pro_cleaned %>%
  mutate(
    age_five_year_slice = factor(
      age_five_year_slice,
      levels = c("000", "005", "010", "015", "020", "025", "030", "035", "040", "045", 
                 "050", "055", "060", "065", "070", "075", "080", "085", "090", "095", 
                 "100", "105", "110", "115", "120"),
      labels = c("0-4 years", "5-9 years", "10-14 years", "15-19 years", "20-24 years", 
                 "25-29 years", "30-34 years", "35-39 years", "40-44 years", "45-49 years", 
                 "50-54 years", "55-59 years", "60-64 years", "65-69 years", "70-74 years", 
                 "75-79 years", "80-84 years", "85-89 years", "90-94 years", "95-99 years", 
                 "100-104 years", "105-109 years", "110-114 years", "115-119 years", "120+ years"),
      ordered = TRUE
    ),
    socio_professional_cat = factor(
      socio_professional_cat,
      levels = c(1, 2, 3, 4, 5, 6, 7, 8),
      labels = c("Agriculteurs exploitants", "Artisans", "Cadres", 
                 "Professions Intermédiaires", "Employés", "Ouvriers", "Retraités", "Autres"),
      ordered = FALSE
    ),
    highest_qualification = factor(
      highest_qualification,
      levels = c("01", "02", "03", "11", "12", "13", "14", "15", "16", "17", "18", "19", "ZZ"),
      labels = c("No schooling", "Primary or lower", "Secondary or higher", "CEP", "BEPC", 
                 "CAP/BEP", "General Bac", "Professional Bac", "BTS/DUT", 
                 "Bachelor", "Master", "Doctorate", "Not Applicable"),
      ordered = TRUE
    ),
    employment_condition = factor(
      employment_condition,
      levels = c("11", "12", "13", "14", "15", "16", "21", "22", "23", "ZZ"),
      labels = c("Apprenticeship", "Temporary Agency", "Supported Jobs", "Interns", 
                 "Limited Term", "Unlimited Term", "Independent", "Employers", "Family Aids", 
                 "Not Applicable"),
      ordered = FALSE
    ),
    workplace_indicator = factor(
      workplace_indicator,
      levels = c(1, 2, 3, 4, 5, 6, 7, "Z"),
      labels = c("Within Residence Commune", "Other Commune (Same Dept.)", 
                 "Other Dept. (Same Region)", "Outside Region: Metropole", 
                 "Outside Region: DOM", "Outside Region: COM", "Abroad", "Not Applicable"),
      ordered = TRUE
    ),
    urban_workplace_indicator = factor(
      urban_workplace_indicator,
      levels = c(1, 2, 3, 4, 5, "Z"),
      labels = c("Rural: Same Commune", "Rural: Outside Commune", 
                 "Urban: Same Commune", "Urban: Same Urban Unit", 
                 "Urban: Outside Urban Unit", "Not Applicable"),
      ordered = TRUE
    ),
    metrodom_indicator = factor(
      metrodom_indicator,
      levels = c("M", "D"),
      labels = c("Metropolitan France", "DOM"),
      ordered = FALSE
    ),
    economic_activity = factor(
      economic_activity,
      levels = c("AZ", "BE", "FZ", "GU", "OQ", "ZZ"),
      labels = c("Agriculture", "Industry", "Construction", 
                 "Commerce/Transport/Services", 
                 "Public Admin/Education/Health", "Not Applicable"),
      ordered = FALSE
    ),
    sexe = factor(
      sexe,
      levels = c(1, 2),
      labels = c("Male", "Female"),
      ordered = FALSE
    ),
    professional_status = factor(
      professional_status,
      levels = c(10, 21, 22, 23, "ZZ"),
      labels = c("Salaried", "Independent", "Employers", 
                 "Family Aids", "Not Applicable"),
      ordered = FALSE
    ),
    occupancy_status_accomodation = factor(
      occupancy_status_accomodation,
      levels = c("00", "10", "21", "22", "23", "30", "ZZ"),
      labels = c("Unoccupied", "Owner", "Renter (Private Non-HLM)", 
                 "Renter (HLM)", "Renter (Furnished/Hotel)", 
                 "Free Lodging", "Not Applicable"),
      ordered = FALSE
    ),
    working_time = factor(
      working_time,
      levels = c(1, 2, "Z"),
      labels = c("Full-time", "Part-time", "Not Applicable"),
      ordered = FALSE
    ),
    main_transportation_work = factor(
      main_transportation_work,
      levels = c(1, 2, 3, 4, 5, 6, "Z"),
      labels = c("No Transport", "On Foot", "Bicycle", 
                 "Motorized Two-Wheelers", "Car/Truck/Van", 
                 "Public Transport", "Not Applicable"),
      ordered = FALSE
    ),
    accomodation_type = factor(
      accomodation_type,
      levels = c(1, 2, 3, 4, 5, 6, "Z"),
      labels = c("House", "Apartment", "Foyer", "Hotel Room", 
                 "Improvised Housing", "Independent Room", 
                 "Not Applicable"),
      ordered = FALSE
    ),
    type_of_household = factor(
      type_of_household,
      levels = c("11", "12", "20", "31", "32", "41", "42", "43", "44", "ZZ"),
      labels = c("Single Male", "Single Female", "Multiple Persons (No Family)", 
                 "Single Parent (Male)", "Single Parent (Female)", 
                 "Couple (Two Working)", "Couple (Male Working)", 
                 "Couple (Female Working)", "Couple (Both Non-working)", 
                 "Not Applicable"),
      ordered = FALSE
    )
  )
```

### Removing duplicates

```{r}
library(dplyr)

# Store initial row counts
initial_rows <- sapply(list(
  stops_france_cleaned
), nrow)

# Stops France dataset
stops_france_cleaned <- stops_france_cleaned %>% 
  distinct()
cat("Stops France: Removed", nrow(stops_france) - nrow(stops_france_cleaned), "duplicate rows.\n")

# Store final row counts
final_rows <- sapply(list(
  stops_france_cleaned
), nrow)

# Summarize row changes
datasets <- c("Stops France")
row_summary <- data.frame(
  Dataset = datasets,
  Initial_Rows = initial_rows,
  Final_Rows = final_rows,
  Duplicates_Removed = initial_rows - final_rows
)

# Print the summary
print(row_summary)
```

# Data Joining {#data-joining}

### Joining local_mob_cleaned and revenus_cleaned

```{r}
merged_local_mob_revenus <- local_mob_cleaned %>%
  inner_join(revenus_cleaned, by = "communal_code") %>%
  select(-communal_label.y) %>% 
  rename(communal_label = communal_label.x)

# Update datasets_cleaned
datasets_cleaned$local_mob <- NULL  # Remove local_mob_cleaned
datasets_cleaned$revenus <- NULL   # Remove revenus_cleaned
datasets_cleaned$merged_local_mob_revenus <- merged_local_mob_revenus  # Add the merged dataset

```

### From Commune to Intercommunalité

```{r}
library(vroom)
library(here)
here::i_am("Final_Project_Commuter_behavior.Rproj")

source <- "https://www.data.gouv.fr/fr/datasets/r/7acc46ad-1c79-43d9-8f2d-d0a8ec78c068"
local_name <- "COM_to_EPCI.csv.gz"
local_dir <- "data"
## is the directory available?
if (!dir.exists(here(local_dir))) {
  ## create the directory if needed
  dir.create(here(local_dir))
}
## is the file available?
if (!file.exists(here(local_dir, local_name))) {
  ## we need to download it
  COM_to_EPCI <- vroom(source)
  ## let's save the file to avoid useless downloading
  vroom_write(COM_to_EPCI, here(local_dir, local_name), delim = ",")
} else {
  ## we need only to load it
  COM_to_EPCI <- vroom(here(local_dir, local_name))
}
```

Keep only the variables we are interested in:

-   codeCommune

-   nomCommune

-   codeEPCI

-   nomEPCI

-   latitude

-   longitude

```{r}
## Filter the dataset to keep only the required variables
COM_to_EPCI_filtered <- COM_to_EPCI %>%
  select(codeCommune, nomCommune, codeEPCI, nomEPCI, latitude, longitude)

# Update datasets_cleaned
datasets_cleaned$COM_to_EPCI <- COM_to_EPCI_filtered


```

### Filtering and selecting relevant columns

**OBJECTIVE**

We are looking to have one big dataset that includes the following
columns:

From:

demo...

-   intercommunal code

-   intercommunal label

-   population

-   density

iltduu...

-   urban workplace indicator

-   sexe

-   main transportation work

-   number of "occurences"

stops_france...

-   nb of stops per intercommune

mob_pro...

-   age

-   socio prof cat

-   nb of two-wheelers

-   highest qualification

-   number people per household

-   number cars per household

-   type of household

-   working time

-   accomodation type

merged_local_mob_revenus...

-   share_worker_public_transport

-   share_household_car

-   share_car_for_work

-   share_bike_for_work

-   number_households

-   median_living_standard

**PLAN**

Filter rows to keep only relevant observations based on your research
question. Select columns that are directly relevant for your analysis,
discarding unnecessary ones.

Identify Relevant Columns for Each Dataset: Decide which variables are
necessary based on your research question (e.g., geographic identifiers,
socio-professional categories, commuting modes).

Filter Rows: Exclude rows that don’t contribute to your analysis (e.g.,
NA values or out-of-scope observations). Use filter() to narrow down
data. Select Columns: Use select() to keep only the necessary columns.

Then aggregate to have it at Intercommunalité level.

**ILTDUU**

1.  Filter out geotype and create a new dataset containing only the
    following variables:

-   urban_workplace_indicator

-   sexe

-   main_transportation_work

-   nb

2.  Aggregate at Intercommunalité level

```{r}
# Keep only the first occurrence of each codeCommune
COM_to_EPCI_filtered_unique <- COM_to_EPCI_filtered %>%
  distinct(codeCommune, .keep_all = TRUE)

# Add codeEPCI to iltduu_sexe_trans_cleaned based on communal_code and codeCommune
iltduu_transformed <- iltduu_sexe_trans_cleaned %>%
  left_join(
    COM_to_EPCI_filtered_unique %>% select(codeCommune, codeEPCI),
    by = c("communal_code" = "codeCommune"),
    relationship = "many-to-many"
  )

```

```{r}
# Aggregate data to have 60 entries per codeEPCI
iltduu_aggregated <- iltduu_transformed %>%
  group_by(
    codeEPCI,
    urban_workplace_indicator,
    sexe,
    main_transportation_work
  ) %>%
  summarise(
    nb = sum(nb, na.rm = TRUE),  # Sum 'nb' for each combination of grouping variables
    .groups = "drop"            # Avoid warnings about grouped data
  )

# Validate the number of entries per codeEPCI
entries_per_codeEPCI <- iltduu_aggregated %>%
  count(codeEPCI) %>%
  filter(n != 60)  # Check if any codeEPCI does not have 60 entries

print(entries_per_codeEPCI)

# Checking no data is lost

# Sum of the nb column in iltduu_aggregated
sum_iltduu_aggregated <- sum(iltduu_aggregated$nb, na.rm = TRUE)

# Sum of the nb column in iltduu_transformed
sum_iltduu_transformed <- sum(iltduu_transformed$nb, na.rm = TRUE)

sum_iltduu_aggregated
sum_iltduu_transformed
```

**merged_local_mob_revenus**

Aggregate data

```{r}
# Step 1: Add codeEPCI to merged_local_mob_revenus
merged_local_mob_revenus_transformed <- merged_local_mob_revenus %>%
  left_join(
    COM_to_EPCI_filtered_unique %>% select(codeCommune, codeEPCI),
    by = c("communal_code" = "codeCommune"),
    relationship = "many-to-many"
  )

# Step 2: Aggregate data at the Intercommunalité level (codeEPCI)
merged_local_mob_revenus_aggregated <- merged_local_mob_revenus_transformed %>%
  group_by(codeEPCI) %>%
  summarise(
    # Weighted average for share_worker_public_transport
    share_worker_public_transport = sum(share_worker_public_transport * number_household_2021, na.rm = TRUE) / sum(number_household_2021, na.rm = TRUE),
    
    # Weighted average for share_household_car
    share_household_car = sum(share_household_car * number_household_2021, na.rm = TRUE) / sum(number_household_2021, na.rm = TRUE),
    
    # Weighted average for share_car_for_work
    share_car_for_work = sum(share_car_for_work * number_household_2021, na.rm = TRUE) / sum(number_household_2021, na.rm = TRUE),
    
    # Weighted average for share_bike_for_work
    share_bike_for_work = sum(share_bike_for_work * number_household_2021, na.rm = TRUE) / sum(number_household_2021, na.rm = TRUE),
    
    # Summing the total number of households
    number_household_2021 = sum(number_household_2021, na.rm = TRUE),
    
    # Weighted average for median_living_standard
    median_living_standard_2021 = sum(median_living_standard_2021 * number_household_2021, na.rm = TRUE) / sum(number_household_2021, na.rm = TRUE),
    
    .groups = "drop" # Avoid warnings about grouped data
  )
```

**stops_france**

1.  Make sure stops_france doesn't have any duplicates left.

```{r}
stops_france_noduplicates <- stops_france_cleaned %>%
  distinct(dataset_custom_title, stop_name, .keep_all = TRUE)

# distinct(dataset_custom_title, stop_name, .keep_all = TRUE) ensures that only unique combinations of dataset_custom_title and stop_name remain in the dataset.
```

2.  Use each stops lon/lat to associate with an "intercommune" and
    indicate nb of stops per intercommune.

Use spatial tools to assign stops to codeEPCI (if lon/lat is available).

Using the sf package:

```{r}
#Filter Out Rows with Missing Coordinates
COM_to_EPCI_filtered <- COM_to_EPCI_filtered %>%
  filter(!is.na(longitude) & !is.na(latitude))
stops_france_noduplicates <- stops_france_noduplicates %>%
  filter(!is.na(stop_lon) & !is.na(stop_lat))

library(sf)

# Convert datasets to sf objects
stops_sf <- stops_france_noduplicates %>%
  st_as_sf(coords = c("stop_lon", "stop_lat"), crs = 4326)  # Assign CRS (e.g., WGS 84)

epci_sf <- COM_to_EPCI_filtered %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)  

# Perform spatial join
stops_france_ready <- st_join(stops_sf, epci_sf, join = st_nearest_feature)

# Group by codeEPCI and count the number of stops
stops_summary <- stops_france_ready %>%
  group_by(codeEPCI) %>%
  summarise(nb_stops = n(), .groups = "drop")

stops_summary <- stops_summary %>%
  st_drop_geometry()

```

**mob_pro**

1.  Filter such that we only keep the following variables:

-   age
-   socio prof cat
-   nb of two-wheelers
-   highest qualification
-   number people per household
-   number cars per household
-   type of household
-   working time
-   accomodation type

```{r}
# Select only the required columns
mob_pro_filtered <- mob_pro_cleaned %>%
  select(
    communal_code,                    # Communal code
    age_five_year_slice,              # Age
    socio_professional_cat,           # Socio-professional category
    nb_household_two_wheelers,        # Number of two-wheelers
    highest_qualification,            # Highest qualification
    number_people_household,          # Number of people per household
    number_car_household,             # Number of cars per household
    type_of_household,                # Type of household
    working_time,                     # Working time
    accomodation_type,                # Accommodation type
    workplace_indicator,              # Workplace indicator 1
    urban_workplace_indicator         # Workplace indicator 2
  )
```

Now aggregate

```{r}
# Step 1: Add codeEPCI to mob_pro_filtered
mob_pro_transformed <- mob_pro_filtered %>%
  left_join(
    COM_to_EPCI_filtered_unique %>% select(codeCommune, codeEPCI),
    by = c("communal_code" = "codeCommune"),
    relationship = "many-to-many"
  )

mob_pro_aggregated <- mob_pro_transformed %>%
  group_by(
    codeEPCI, 
    age_five_year_slice, 
    socio_professional_cat, 
    highest_qualification, 
    type_of_household, 
    working_time, 
    accomodation_type, 
    workplace_indicator, 
    urban_workplace_indicator
  ) %>%
  summarise(
    nb_household_two_wheelers = mean(nb_household_two_wheelers, na.rm = TRUE),  # Mean number of two-wheelers
    number_people_household = mean(number_people_household, na.rm = TRUE),      # Mean number of people per household
    number_car_household = mean(number_car_household, na.rm = TRUE),            # Mean number of cars per household
    .groups = "drop" # Avoid warnings about grouped data
  )

```

### Datasets ready for join by codeEPCI

-   demo_cleaned
-   iltduu_aggregated
-   merged_local_mob_revenus_aggregated
-   stops_summary
-   mob_pro_aggregated

### Join demo and stops

There are not the same number of rows, let's look into that.

```{r}
# Extract codeEPCI from both datasets
demo_codeEPCI <- demo_cleaned$intercommunal_code  
stops_codeEPCI <- stops_summary$codeEPCI          

# Find codes in demo_cleaned but not in stops_summary
missing_in_stops <- setdiff(demo_codeEPCI, stops_codeEPCI)

# Create a data frame for the missing codeEPCI values
missing_stops <- data.frame(
  codeEPCI = missing_in_stops,
  nb_stops = 0  # Assign 0 for nb_stops
)

# Convert codeEPCI in both data frames to double
stops_summary <- stops_summary %>%
  mutate(codeEPCI = as.double(codeEPCI))

missing_stops <- missing_stops %>%
  mutate(codeEPCI = as.double(codeEPCI))

# Append the missing_stops data frame to stops_summary
stops_summary_updated <- stops_summary %>%
  bind_rows(missing_stops)

# Remove rows where nb_stops is NA
stops_summary_updated <- stops_summary_updated %>%
  filter(!is.na(nb_stops))

```

Now there are 1266 entries in stops_summary_updated. However only 1255
in demo_cleaned. There are 11 codeEPCIs that are missing in
demo_cleaned.

```{r}
# Extract the EPCI codes from both datasets
demo_epci_codes <- demo_cleaned$intercommunal_code
com_to_epci_codes <- COM_to_EPCI_filtered$codeEPCI

# Find the EPCI codes in COM_to_EPCI_filtered that are missing in demo_cleaned and remove NA values
missing_epci_codes <- setdiff(com_to_epci_codes, demo_epci_codes)
missing_epci_codes <- missing_epci_codes[!is.na(missing_epci_codes)]  # Filter out NA values


# Display the missing EPCI codes
print(missing_epci_codes)

# Filter COM_to_EPCI_filtered to find rows matching the missing_epci_codes
missing_epci_details <- COM_to_EPCI_filtered %>%
  filter(codeEPCI %in% missing_epci_codes) %>%
  select(codeEPCI, nomEPCI)

# Remove duplicates
missing_epci_details_unique <- missing_epci_details %>%
  distinct()

# Display the result
print(missing_epci_details_unique)

```

So in demo_cleaned, we are missing quite many values regarding Paris.
This will make our analysis less accurate.

ADD 16 NA to those EPCI.

Perform the join.

```{r}

# Convert intercommunal_code in demo_cleaned to numeric
demo_cleaned <- demo_cleaned %>%
  mutate(intercommunal_code = as.numeric(intercommunal_code))

# Perform the left join
demo_stops <- demo_cleaned %>%
  left_join(
    stops_summary_updated %>% select(codeEPCI, nb_stops),
    by = c("intercommunal_code" = "codeEPCI")
  )

# Replace NA in nb_stops with 0
demo_stops <- demo_stops %>%
  mutate(nb_stops = ifelse(is.na(nb_stops), 0, nb_stops))


# Comment on missing matches
missing_intercommunal_code <- setdiff(stops_summary_updated$codeEPCI, demo_cleaned$intercommunal_code)
cat("The following codeEPCI values do not have matching intercommunal_code in demo_cleaned:\n")
print(missing_intercommunal_code)

```

Métropole du Grand Paris arrives 18th in number of stops. Seems odd and
unlikely.

We should still handle the "NA" in the resulting dataset.

### Handle missing two wheeler observations in mob pro dataset

```{r}
# Step 2: Handle missing values in nb_household_two_wheelers

# Calculate the proportion of NaN (missing) values in nb_household_two_wheelers
nan_proportion <- sum(is.na(mob_pro_aggregated$nb_household_two_wheelers)) / nrow(mob_pro_aggregated)
cat("Proportion of NaN in nb_household_two_wheelers: ", nan_proportion, "\n")

# If NaN proportion is significant (e.g., more than 30%), decide on an action
if (nan_proportion > 0.3) {
  cat("More than 30% missing values. Considering removing nb_household_two_wheelers.\n")
  
  # Option 1: Remove the column entirely
  mob_pro_aggregated <- mob_pro_aggregated %>%
    select(-nb_household_two_wheelers)
  
  # Option 2: Alternatively, you could rename NaN values to something more meaningful (if appropriate)
  # mob_pro_cleaned <- mob_pro_cleaned %>%
  #   mutate(nb_household_two_wheelers = ifelse(is.na(nb_household_two_wheelers), "Unknown", nb_household_two_wheelers))
} else {
  cat("Less than 30% missing values. Renaming or imputing missing values.\n")
  
  # Option to rename NaN values to something like "Unknown"
  mob_pro_aggregated <- mob_pro_aggregated %>%
    mutate(nb_household_two_wheelers = ifelse(is.na(nb_household_two_wheelers), "Unknown", nb_household_two_wheelers))
}

# Check the updated dataset
summary(mob_pro_aggregated$nb_household_two_wheelers)
```

### Latest Datasets and Their Contents:

1.  **demo_stops**

This is the primary dataset after joining demo_cleaned and
stops_summary_updated. It contains demographic data at the
intercommunalité level (from demo_cleaned) along with the number of
public transportation stops (from stops_summary_updated). Any missing
values in the nb_stops column have been filled, and the
intercommunal_code and intercommunal_label are updated based on the
codeEPCI and nomEPCI from stops_summary_updated.

2.  **iltduu_aggregated**

Contains aggregated transportation data (e.g., types of transportation,
urban workplace indicators, and socio-economic data) from
iltduu_sexe_trans_cleaned at the intercommunalité level.

3.  **merged_local_mob_revenus_aggregated**

Contains aggregated mobility and revenue data, including variables like
the share of people using different modes of transportation and other
economic indicators, aggregated at the intercommunalité level.

4.  **mob_pro_aggregated**

Contains aggregated socio-economic data at the intercommunalité level,
including variables like age groups, socio-professional categories,
household data (e.g., number of people per household, number of cars),
and employment conditions. Missing values in the
nb_household_two_wheelers column have been handled.

### Investigate the unique observations of codeEPCI values for each dataset

```{r}
# Step 1: Rename intercommunal_code to codeEPCI in demo_stops for consistency
demo_stops <- demo_stops %>%
  rename(codeEPCI = intercommunal_code)

```

```{r}
# Step 1: Extract unique codeEPCI values from each dataset
demo_stops_unique_codes <- unique(demo_stops$codeEPCI)
mob_pro_unique_codes <- unique(mob_pro_aggregated$codeEPCI)
iltduu_unique_codes <- unique(iltduu_aggregated$codeEPCI)
merged_local_mob_revenus_unique_codes <- unique(merged_local_mob_revenus_aggregated$codeEPCI)

# Step 2: List the number of unique codeEPCI values in each dataset
cat("Unique codeEPCI in demo_stops: ", length(demo_stops_unique_codes), "\n")
cat("Unique codeEPCI in mob_pro_aggregated: ", length(mob_pro_unique_codes), "\n")
cat("Unique codeEPCI in iltduu_aggregated: ", length(iltduu_unique_codes), "\n")
cat("Unique codeEPCI in merged_local_mob_revenus_aggregated: ", length(merged_local_mob_revenus_unique_codes), "\n")
```

**Only keeping the observations with codeEPCI that are common to all
datasets**

```{r}
# Step 1: Identify the common codeEPCI values across all datasets
common_codeEPCI <- Reduce(intersect, list(
  demo_stops$codeEPCI,
  mob_pro_aggregated$codeEPCI,
  iltduu_aggregated$codeEPCI,
  merged_local_mob_revenus_aggregated$codeEPCI
))

# Step 2: Filter each dataset to keep only rows with codeEPCI in the common set
demo_stops_filtered <- demo_stops %>%
  filter(codeEPCI %in% common_codeEPCI)

mob_pro_aggregated_filtered <- mob_pro_aggregated %>%
  filter(codeEPCI %in% common_codeEPCI)

iltduu_aggregated_filtered <- iltduu_aggregated %>%
  filter(codeEPCI %in% common_codeEPCI)

merged_local_mob_revenus_aggregated_filtered <- merged_local_mob_revenus_aggregated %>%
  filter(codeEPCI %in% common_codeEPCI)

# Step 3: Check the number of unique codeEPCI values in each filtered dataset
cat("Unique codeEPCI in demo_stops_filtered: ", length(unique(demo_stops_filtered$codeEPCI)), "\n")
cat("Unique codeEPCI in mob_pro_aggregated_filtered: ", length(unique(mob_pro_aggregated_filtered$codeEPCI)), "\n")
cat("Unique codeEPCI in iltduu_aggregated_filtered: ", length(unique(iltduu_aggregated_filtered$codeEPCI)), "\n")
cat("Unique codeEPCI in merged_local_mob_revenus_aggregated_filtered: ", length(unique(merged_local_mob_revenus_aggregated_filtered$codeEPCI)), "\n")
```

### Joining demo_stops_filtered and merged_local_mob_revenus_aggregated_filtered

```{r}
# Step 1: Join demo_stops_filtered and merged_local_mob_revenus_aggregated_filtered
demo_stops_and_revenues <- demo_stops_filtered %>%
  left_join(merged_local_mob_revenus_aggregated_filtered, by = "codeEPCI")

# Check the result
cat("Number of rows after demo_stops and merged_local_mob_revenus_aggregated join: ", nrow(demo_stops_and_revenues), "\n")
head(demo_stops_and_revenues)
```

After following the steps, the latest datasets to be used for the join
are:

1.  **demo_stops_and_revenues:**

This dataset is the result of joining demo_stops_filtered and
merged_local_mob_revenus_aggregated_filtered. It contains the codeEPCI
and corresponding public transport stop data along with revenue data at
the intercommunalité level.

2.  **iltduu_aggregated_filtered:**

This dataset contains aggregated transportation-related data (e.g.,
worker transport shares, household car shares) at the codeEPCI level,
after the necessary aggregation.

3.  **mob_pro_aggregated_filtered**:

This dataset contains aggregated socio-economic data (e.g., number of
households with two-wheelers, number of people per household) at the
codeEPCI level, after the necessary aggregation.

### Aggregating iltduu_aggregated_filtered

```{r}
# Summarize data at the codeEPCI level for iltduu_aggregated_filtered
iltduu_aggregated_final <- iltduu_aggregated_filtered %>%
  group_by(codeEPCI) %>%
  summarise(
    total_nb = sum(nb, na.rm = TRUE),
    male_share = sum(nb[sexe == "Male"], na.rm = TRUE) / total_nb,
    female_share = sum(nb[sexe == "Female"], na.rm = TRUE) / total_nb,
    # Summarize other variables as necessary (e.g., transportation mode)
    no_transport_share = sum(nb[main_transportation_work == "No Transport"], na.rm = TRUE) / total_nb,
    on_foot_share = sum(nb[main_transportation_work == "On Foot"], na.rm = TRUE) / total_nb,
    bicycle_share = sum(nb[main_transportation_work == "Bicycle"], na.rm = TRUE) / total_nb,
    motorized_two_wheelers_share = sum(nb[main_transportation_work == "Motorized Two Wheelers"], na.rm = TRUE) / total_nb,
    car_truck_van_share = sum(nb[main_transportation_work == "Car, Truck, Van"], na.rm = TRUE) / total_nb,
    public_transport_share = sum(nb[main_transportation_work == "Public Transport"], na.rm = TRUE) / total_nb,
    .groups = "drop"
  )
```

### Aggregating mob_pro_aggregated_filtered

```{r}
# Summarize data at the codeEPCI level for mob_pro_aggregated_filtered
mob_pro_aggregated_final <- mob_pro_aggregated_filtered %>%
  group_by(codeEPCI) %>%
  summarise(
    total_people = sum(number_people_household, na.rm = TRUE),  # Total people per codeEPCI
    total_cars = sum(number_car_household, na.rm = TRUE),        # Total cars per codeEPCI

    # Calculate share for age categories
    age_15_19_share = sum(number_people_household[age_five_year_slice == "15-19 years"], na.rm = TRUE) / total_people,
    age_20_24_share = sum(number_people_household[age_five_year_slice == "20-24 years"], na.rm = TRUE) / total_people,
    age_25_29_share = sum(number_people_household[age_five_year_slice == "25-29 years"], na.rm = TRUE) / total_people,
    age_30_34_share = sum(number_people_household[age_five_year_slice == "30-34 years"], na.rm = TRUE) / total_people,
    age_35_39_share = sum(number_people_household[age_five_year_slice == "35-39 years"], na.rm = TRUE) / total_people,
    age_40_44_share = sum(number_people_household[age_five_year_slice == "40-44 years"], na.rm = TRUE) / total_people,
    age_45_49_share = sum(number_people_household[age_five_year_slice == "45-49 years"], na.rm = TRUE) / total_people,
    age_50_54_share = sum(number_people_household[age_five_year_slice == "50-54 years"], na.rm = TRUE) / total_people,
    age_55_59_share = sum(number_people_household[age_five_year_slice == "55-59 years"], na.rm = TRUE) / total_people,
    age_60_64_share = sum(number_people_household[age_five_year_slice == "60-64 years"], na.rm = TRUE) / total_people,
    age_65_69_share = sum(number_people_household[age_five_year_slice == "65-69 years"], na.rm = TRUE) / total_people,
    age_70_74_share = sum(number_people_household[age_five_year_slice == "70-74 years"], na.rm = TRUE) / total_people,
    age_75_79_share = sum(number_people_household[age_five_year_slice == "75-79 years"], na.rm = TRUE) / total_people,
    age_80_84_share = sum(number_people_household[age_five_year_slice == "80-84 years"], na.rm = TRUE) / total_people,
    age_85_89_share = sum(number_people_household[age_five_year_slice == "85-89 years"], na.rm = TRUE) / total_people,
    age_90_94_share = sum(number_people_household[age_five_year_slice == "90-94 years"], na.rm = TRUE) / total_people,
    age_95_99_share = sum(number_people_household[age_five_year_slice == "95-99 years"], na.rm = TRUE) / total_people,

    # Calculate share for socio-professional categories
    agri_exploitants_share = sum(number_people_household[socio_professional_cat == "Agriculteurs exploitants"], na.rm = TRUE) / total_people,
    artisans_share = sum(number_people_household[socio_professional_cat == "Artisans"], na.rm = TRUE) / total_people,
    cadres_share = sum(number_people_household[socio_professional_cat == "Cadres"], na.rm = TRUE) / total_people,
    professions_intermediaires_share = sum(number_people_household[socio_professional_cat == "Professions Intermédiaires"], na.rm = TRUE) / total_people,
    employes_share = sum(number_people_household[socio_professional_cat == "Employés"], na.rm = TRUE) / total_people,
    ouvriers_share = sum(number_people_household[socio_professional_cat == "Ouvriers"], na.rm = TRUE) / total_people,
    
    # Calculate share for highest qualification
    no_schooling_share = sum(number_people_household[highest_qualification == "No schooling"], na.rm = TRUE) / total_people,
    primary_or_lower_share = sum(number_people_household[highest_qualification == "Primary or lower"], na.rm = TRUE) / total_people,
    secondary_or_higher_share = sum(number_people_household[highest_qualification == "Secondary or higher"], na.rm = TRUE) / total_people,
    cep_share = sum(number_people_household[highest_qualification == "CEP"], na.rm = TRUE) / total_people,
    bepc_share = sum(number_people_household[highest_qualification == "BEPC"], na.rm = TRUE) / total_people,
    cap_bep_share = sum(number_people_household[highest_qualification == "CAP/BEP"], na.rm = TRUE) / total_people,
    general_bac_share = sum(number_people_household[highest_qualification == "General Bac"], na.rm = TRUE) / total_people,
    professional_bac_share = sum(number_people_household[highest_qualification == "Professional Bac"], na.rm = TRUE) / total_people,
    bts_dut_share = sum(number_people_household[highest_qualification == "BTS/DUT"], na.rm = TRUE) / total_people,
    bachelor_share = sum(number_people_household[highest_qualification == "Bachelor"], na.rm = TRUE) / total_people,
    master_share = sum(number_people_household[highest_qualification == "Master"], na.rm = TRUE) / total_people,
    doctorate_share = sum(number_people_household[highest_qualification == "Doctorate"], na.rm = TRUE) / total_people,
 
    # Calculate share for workplace indicator
    within_residence_commune_share = sum(number_people_household[workplace_indicator == "Within Residence Commune"], na.rm = TRUE) / total_people,
    other_commune_same_dept_share = sum(number_people_household[workplace_indicator == "Other Commune (Same Dept.)"], na.rm = TRUE) / total_people,
    other_dept_same_region_share = sum(number_people_household[workplace_indicator == "Other Dept. (Same Region)"], na.rm = TRUE) / total_people,
    outside_region_metropole_share = sum(number_people_household[workplace_indicator == "Outside Region: Metropole"], na.rm = TRUE) / total_people,
    outside_region_dom_share = sum(number_people_household[workplace_indicator == "Outside Region: DOM"], na.rm = TRUE) / total_people,
    outside_region_com_share = sum(number_people_household[workplace_indicator == "Outside Region: COM"], na.rm = TRUE) / total_people,
    abroad_share = sum(number_people_household[workplace_indicator == "Abroad"], na.rm = TRUE) / total_people,
    .groups = "drop"
  )
```

Final datasets for joining:

-   mob_pro_aggregated_final

-   iltduu_aggregated_final

-   demo_stops_and_revenues

### Modifying the age category

```{r}
# Aggregate age slices into 10-year intervals
mob_pro_aggregated_final <- mob_pro_aggregated_final %>%
  mutate(
    age_15_24_share = age_15_19_share + age_20_24_share,
    age_25_34_share = age_25_29_share + age_30_34_share,
    age_35_44_share = age_35_39_share + age_40_44_share,
    age_45_54_share = age_45_49_share + age_50_54_share,
    age_55_64_share = age_55_59_share + age_60_64_share,
    age_65_74_share = age_65_69_share + age_70_74_share,
    age_75_84_share = age_75_79_share + age_80_84_share,
    age_85_94_share = age_85_89_share + age_90_94_share
  ) %>%
  select(
    -age_15_19_share, -age_20_24_share, 
    -age_25_29_share, -age_30_34_share, 
    -age_35_39_share, -age_40_44_share, 
    -age_45_49_share, -age_50_54_share, 
    -age_55_59_share, -age_60_64_share, 
    -age_65_69_share, -age_70_74_share, 
    -age_75_79_share, -age_80_84_share, 
    -age_85_89_share, -age_90_94_share,
  )

```

```{r}
mob_pro_aggregated_final <- mob_pro_aggregated_final %>% select(-age_95_99_share)
```

### Final joining

```{r}
# Perform the joins
final_dataset <- demo_stops_and_revenues %>%
  left_join(iltduu_aggregated_final, by = "codeEPCI") %>%
  left_join(mob_pro_aggregated_final, by = "codeEPCI")

# Optionally save the final dataset
write.csv(final_dataset, "final_dataset.csv", row.names = FALSE)
```

# Cleaning the join {#cleaning-the-join}

### Removing Missing Values

```{r}
# Identify missing values in the dataset
missing_summary <- final_dataset %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

print(missing_summary)

final_dataset_2 <- final_dataset %>%
  mutate(across(where(is.numeric), ~ replace_na(., 0))) %>%
  mutate(across(where(is.character), ~ replace_na(., "Unknown")))

missing_summary <- final_dataset_2 %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "MissingCount")

print(missing_summary)
```

List of the Intercommunautés with only zeros for categories :
share_worker_public_transport, share_household_car, share_car_for_work,
share_bike_for_work

-   Communauté d'agglomération Cap Excellence (200018653)

-   Communauté de communes des Savanes (200027548)

-   Communauté d'agglomération La Riviera du Levant (200041507)

-   Communauté d'agglomération du Nord Grande Terre (200044691)

-   Communauté de communes de Marie-Galante (249710047)

-   Communauté d'agglomération du Nord Basse-Terre (249710062)

-   Communauté d'agglomération Grand Sud Caraïbe (249710070)

-   Communauté de communes de l'Ouest Guyanais (249730037)

-   Communauté d'agglomération du Centre Littoral (249730045)

-   Communauté de communes de l'Est Guyanais (249730052)

### Handle Duplicates

```{r}
# Check for duplicate rows
duplicates <- final_dataset_2 %>%
  duplicated()

cat("Number of duplicate rows:", sum(duplicates), "\n")

view(duplicates)
```

### Normalize Column Names

```{r}
library(janitor)

# Clean column names
final_dataset_3 <- final_dataset_2 %>%
  clean_names()

# Verify the column names
print(names(final_dataset))

```

### Validate and Adjust Data Types

```{r}
# Check the data types of each column
str(final_dataset)

# Convert columns to appropriate data types
final_dataset_4 <- final_dataset_3 %>%
  mutate(
    code_epci = as.character(code_epci),  # Convert ID column to character
    total_people = as.numeric(total_people),  # Convert numeric columns
    municipal_population_2021 = as.numeric(municipal_population_2021)
  )
str(final_dataset_4)
```

### Remove total_nb and number_households

```{r}
final_dataset_5 <- final_dataset_4 %>% select(-total_nb, -number_household_2021, -total_people, -total_cars)
final_dataset_5 <- final_dataset_5 %>%
  filter(!(code_epci %in% c(247400666, 246000772))) # removing ducplicates
```

### Detect Outliers

```{r}
numeric_cols <- final_dataset_5 %>% select(where(is.numeric))

outliers <- numeric_cols %>%
  summarise(across(everything(), ~ sum(. > quantile(., 0.75, na.rm = TRUE) + 1.5 * IQR(.) |
                                       . < quantile(., 0.25, na.rm = TRUE) - 1.5 * IQR(.), na.rm = TRUE)))

print(outliers)
```

### Handle Redundant Columns

```{r}
# Drop columns with excessive missing values (e.g., >50% NA)
threshold <- 0.5 * nrow(final_dataset_5)
cols_to_drop <- missing_summary %>%
  filter(MissingCount > threshold) %>%
  pull(Variable)
```

### Save the Cleaned Dataset

```{r}

#renaming one variable
final_dataset_5 <- final_dataset_5 %>%
  rename(intercommunal_population_2021 = municipal_population_2021)
```

```{r}
final_dataset_cleaned <- final_dataset_5

# List of columns to exclude
excluded_columns <- c("share_bike_for_work", 
                      "share_worker_public_transport", 
                      "share_car_for_work", 
                      "share_household_car")

# Identify columns with "share" in their names and not in the excluded list
share_columns <- names(final_dataset_cleaned)[
  grepl("share", names(final_dataset_cleaned)) & 
  !(names(final_dataset_cleaned) %in% excluded_columns)
]

# Multiply the relevant columns by 100
final_dataset_cleaned[share_columns] <- lapply(
  final_dataset_cleaned[share_columns], 
  function(x) x * 100
)

# Save the cleaned dataset to a CSV file
write.csv(final_dataset_cleaned, "final_dataset_cleaned.csv", row.names = FALSE)
```

# First exploratory analysis {#first-exploratory-analysis}

### Generate Summary Statistics

```{r}
summary(final_dataset_cleaned)
```

Some columns, such as outside_region_dom_share,
outside_region_com_share, and abroad_share, have minimum and maximum
values of zero or near-zero. This indicates that these variables might
have very low representation or missing data across our dataset.

Intercommunautés where nb_stops is equal to zero.

Communauté de communes des Savanes (200027548) Communauté de communes du
Pays de Trie et du Magnoac (200070795) Communauté de communes Saint Cyr
Mère Boitier (200071645) Communauté de communes du Pays de
Sancey-Belleherbe (242504371) Communauté de communes Altitude 800
(242504488) Communauté de communes du Causse de Labastide-Murat
(244600573) Communauté de communes du Pays de Duras (244700449)
Communauté de communes du Pays de Villersexel (247000714) Communauté de
communes de Semur-en-Brionnais (247103864) Communauté de communes de
Marie-Galante (249710047) Communauté d'agglomération Grand Sud Caraïbe
(249710070) Communauté de communes de l'Ouest Guyanais (249730037)

Columns like municipal_population_2021 and population_density_2021 have
extremely high maximum values (7103801 for population and 8724.50 for
density). This is expected and corresponds to Paris.

Many shares (e.g., public_transport_share, bicycle_share) are skewed
toward the lower end, with very small means or medians compared to their
maximum values. This probably reflects actual behaviors (e.g., low
public transport usage in rural areas).

Age group shares like age_65_74_share and age_85_94_share have minimum
values of zero. This is most likely due to missing data.

### Visualizations {#visualizations}

**Intercommunal population**

```{r}
library(ggplot2)
library(scales) # For formatting axis labels

# Histogram for intercommunal population with formatted x-axis
ggplot(final_dataset_cleaned, aes(x = intercommunal_population_2021)) +
  geom_histogram(binwidth = 1000, fill = "skyblue", color = "black") +
  labs(
    title = "Distribution of Intercommunal Population (2021)",
    x = "Intercommunal Population",
    y = "Count"
  ) +
  scale_x_continuous(labels = comma) + # Format x-axis labels as regular numbers
  theme_minimal()
```

```{r}
library(ggplot2)

# Define the top intercommunalities by population
top_intercommunalities <- final_dataset_cleaned %>%
  arrange(desc(intercommunal_population_2021)) %>%
  head(20)

# Bar chart for top 20 intercommunalities with formatted x-axis
ggplot(top_intercommunalities, aes(x = reorder(intercommunal_label, intercommunal_population_2021), y = intercommunal_population_2021)) +
  geom_bar(stat = "identity", fill = "dodgerblue") +
  coord_flip() +
  labs(
    title = "Top 20 Intercommunalities by Population (2021)",
    x = "Intercommunal Label",
    y = "Population"
  ) +
  scale_y_continuous(labels = comma) + # Format y-axis labels as regular numbers
  theme_minimal()
```

**Popoulation density**

```{r}
# Density plot for population density
ggplot(final_dataset_cleaned, aes(x = population_density_2021)) +
  geom_density(fill = "lightblue", alpha = 0.6) +
  labs(
    title = "Distribution of Population Density (2021)",
    x = "Population Density",
    y = "Density"
  ) +
  scale_x_continuous(labels = comma) + # Format x-axis for better readability
  theme_minimal()

```

**Nb stops**

```{r}
# Histogram for the distribution of the number of stops
ggplot(final_dataset_cleaned, aes(x = nb_stops)) +
  geom_histogram(binwidth = 50, color = "black") +
  labs(
    title = "Distribution of Number of Stops",
    x = "Number of Stops",
    y = "Count of Intercommunalities"
  ) +
  theme_minimal()
```

```{r}
# Top 20 intercommunalities by number of stops
top_nb_stops <- final_dataset_cleaned %>%
  arrange(desc(nb_stops)) %>%
  head(20)

ggplot(top_nb_stops, aes(x = reorder(intercommunal_label, nb_stops), y = nb_stops)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(
    title = "Top 20 Intercommunalities by Number of Stops",
    x = "Intercommunality",
    y = "Number of Stops"
  ) +
  theme_minimal()
```

**Transport type**

```{r}
# Select the relevant columns and pivot to long format
transport_shares_long <- final_dataset_cleaned %>%
  select(
    intercommunal_label, 
    no_transport_share, 
    on_foot_share, 
    bicycle_share, 
    motorized_two_wheelers_share, 
    car_truck_van_share, 
    public_transport_share
  ) %>%
  pivot_longer(
    cols = -intercommunal_label, 
    names_to = "Transport_Type", 
    values_to = "Share"
  )

# Rename transport types for better readability (optional)
transport_shares_long <- transport_shares_long %>%
  mutate(Transport_Type = recode(
    Transport_Type,
    no_transport_share = "No Transport",
    on_foot_share = "On Foot",
    bicycle_share = "Bicycle",
    motorized_two_wheelers_share = "Two-Wheelers",
    car_truck_van_share = "Car/Van",
    public_transport_share = "Public Transport"
  ))
# Calculate mean shares for each transport type
mean_transport_shares <- transport_shares_long %>%
  group_by(Transport_Type) %>%
  summarise(Average_Share = mean(Share, na.rm = TRUE))


# Calculate mean shares for each transport type
mean_shares <- transport_shares_long %>%
  group_by(Transport_Type) %>%
  summarise(Average_Share = mean(Share, na.rm = TRUE))

#Reorder the factor levels directly in the mean_shares dataset

mean_shares <- mean_shares %>%
  mutate(Transport_Type = factor(Transport_Type, levels = c(
    "share_bike_for_work", 
    "share_worker_public_transport", 
    "share_car_for_work", 
    "share_household_car"
  )))

```

```{r}

# Create a bar chart
ggplot(mean_transport_shares, aes(x = reorder(Transport_Type, -Average_Share), y = Average_Share, fill = Transport_Type)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Average Transport Shares Across All Intercommunalities",
    x = "Transport Type",
    y = "Average Share (%)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )
```

**Age shares**

```{r}
# Convert the dataset to a long format for easier visualization
age_shares_long <- final_dataset_cleaned %>%
  select(code_epci, age_15_24_share:age_75_84_share) %>%
  pivot_longer(
    cols = starts_with("age_"),
    names_to = "Age_Group",
    values_to = "Share"
  )

# Calculate average shares for each age group
average_age_shares <- age_shares_long %>%
  group_by(Age_Group) %>%
  summarise(Average_Share = mean(Share, na.rm = TRUE))

# Create the bar chart
ggplot(average_age_shares, aes(x = Age_Group, y = Average_Share, fill = Age_Group)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Average Age Shares Across Intercommunalities",
    x = "Age Group",
    y = "Average Share (%)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**Checking relationships between population density vs. public transport
usage**

```{r}
ggplot(final_dataset_cleaned, aes(x = population_density_2021, y = share_worker_public_transport)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Population Density vs Public Transport Share")

```

### Last comments before analysis

These intercommunautés have a median living standard of "0" due to
missing valus and should be excluded when we conduct the analysis.

-   Communauté de communes de l'Ouest Guyanais (249730037)

-   Communauté de communes des Savanes (200027548)

-   Communauté de communes de Marie-Galante (249710047)

-   Communauté d'agglomération Grand Sud Caraïbe (249710070)

-   Communauté de communes de l'Est Guyanais (249730052)

-   Communauté d'agglomération du Nord Basse-Terre (249710062)

-   Communauté d'agglomération du Nord Grande Terre (200044691)

-   Communauté d'agglomération du Centre Littoral (249730045)

-   Communauté d'agglomération La Riviera du Levant (200041507)

-   Communauté d'agglomération Cap Excellence (200018653)

```{r}
# Create a vector of codeEPCI values
excluded_living_standard <- c(
  249730037, # Communauté de communes de l'Ouest Guyanais
  200027548, # Communauté de communes des Savanes
  249710047, # Communauté de communes de Marie-Galante
  249710070, # Communauté d'agglomération Grand Sud Caraïbe
  249730052, # Communauté de communes de l'Est Guyanais
  249710062, # Communauté d'agglomération du Nord Basse-Terre
  200044691, # Communauté d'agglomération du Nord Grande Terre
  249730045, # Communauté d'agglomération du Centre Littoral
  200041507, # Communauté d'agglomération La Riviera du Levant
  200018653  # Communauté d'agglomération Cap Excellence
)
```

```{r}
# Create a vector of the column names
transport_share_columns <- c(
  "share_worker_public_transport",
  "share_car_for_work",
  "share_bike_for_work"
)

final_dataset_cleaned2.0 <- final_dataset_cleaned %>% select(-transport_share_columns)
```

```{r}
# Check for NA values in all columns
colSums(is.na(final_dataset_cleaned2.0))

# Alternative: Find columns with any NA values
columns_with_na <- colnames(final_dataset_cleaned2.0)[colSums(is.na(final_dataset_cleaned2.0)) > 0]
columns_with_na
```

# Data analysis {#data-analysis}

The dataset contains 1,248 entries and 51 columns. Key variables
include:

-   Demographics: Age groups, gender shares, education levels.

-   Transportation Modes: Shares of commuting by public transport, car,
    bike, etc.

-   Socioeconomic Indicators: Median living standards,
    socio-professional categories.

-   Geographical Data: Population density, number of stops, commuting
    shares (e.g., within-residence commune).

-   Employment Data: Shares by professional categories like artisans,
    cadres, and ouvriers.

In our analysis we will try to proceed with: Exploratory data analysis
(EDA) with visualizations. Statistical tests to assess relationships.
Modeling to predict commuting behavior based on these variables.

1.  Exploratory Data Analysis (EDA) Graphical Representations:

    Use scatterplots, bar charts, and heatmaps to visually explore the
    relationships between: Commuting mode shares (e.g., public
    transport, car) and population density. Income levels and
    transportation choices. Urban/rural classification and commuting
    behavior. Distribution Analysis: Plot histograms or density plots
    for key variables like income, population density, and commuting
    distances.

2.  Statistical Testing

    Use chi-squared tests (chisq.test()) for dependencies between
    categorical variables. For instance: Urban/rural classification vs.
    preferred transportation mode. Socio-professional category vs. car
    ownership.

3.  Causal Analysis with Linear Models

    Fit inear models (lm()) to explore potential causal relationships
    Interpret coefficients to understand the impact of each variable.
    Ensure confounding variables (e.g., age distribution, education
    levels) are included to improve causal inference.

### Exploratory Data Analysis (EDA)

**Scatterplots: Commuting Mode Shares vs. Population Density**

```{r}
# Scatterplot for Public Transport Share vs. Population Density
ggplot(final_dataset_cleaned2.0, aes(x = population_density_2021, y = public_transport_share)) +
  geom_point() +
  labs(
    title = "Public Transport Share vs. Population Density",
    x = "Population Density (2021)",
    y = "Public Transport Share"
  ) +
  theme_minimal()

# Scatterplot for Car Share vs. Population Density
ggplot(final_dataset_cleaned2.0, aes(x = population_density_2021, y = car_truck_van_share)) +
  geom_point() +
  labs(
    title = "Car Share vs. Population Density",
    x = "Population Density (2021)",
    y = "Car Share for Work"
  ) +
  theme_minimal()

```

**Bar Plot: Income Levels vs. Transportation Choices**

```{r}
# Create income categories
final_dataset_cleaned2.0_2 <- final_dataset_cleaned2.0 %>%
  mutate(income_category = cut(
    median_living_standard_2021,
    breaks = quantile(median_living_standard_2021, probs = seq(0, 1, by = 0.25), na.rm = TRUE),
    labels = c("Low", "Mid-Low", "Mid-High", "High"),
    include.lowest = TRUE
  ))


# Melt the data for transportation modes
melted_data <- final_dataset_cleaned2.0_2 %>%
  select(
    income_category,
    no_transport_share,
    on_foot_share,
    bicycle_share,
    motorized_two_wheelers_share,
    car_truck_van_share,
    public_transport_share
  ) %>%
  pivot_longer(
    cols = c(no_transport_share, on_foot_share, bicycle_share, 
             motorized_two_wheelers_share, car_truck_van_share, 
             public_transport_share),
    names_to = "Transport_Mode",
    values_to = "Share"
  )

# Bar plot
ggplot(melted_data, aes(x = income_category, y = Share, fill = Transport_Mode)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Transportation Choices by Income Category",
    x = "Income Category",
    y = "Average Share"
  ) +
  theme_minimal() +
  theme(legend.position = "right")


ggplot(melted_data, aes(x = income_category, y = Share, fill = income_category)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Transportation Choices by Income Category",
    x = "Income Category",
    y = "Average Share"
  ) +
  theme_minimal() +
  theme(legend.position = "none") + # Remove legend since it's redundant with facets
  facet_wrap(~ Transport_Mode, scales = "free_y") # Facet by Transport_Mode

```

**Urban/Rural Classification vs. Commuting Behavior**

The threshold of 150 inhabitants per square kilometer comes from Insee's
official definition of urban units, which are used to differentiate
between urban and rural areas in France.

```{r}
final_dataset_cleaned2.0_3 <- final_dataset_cleaned2.0 %>%
  mutate(urban_rural = ifelse(population_density_2021 > 150, "Urban", "Rural"))

# Boxplot for Urban/Rural vs. Car Share for Work
ggplot(final_dataset_cleaned2.0_3, aes(x = urban_rural, y = car_truck_van_share)) +
  geom_boxplot() +
  labs(
    title = "Car Share for Work by Urban/Rural Classification",
    x = "Urban/Rural",
    y = "Car Share for Work"
  ) +
  theme_minimal()
```

**Correlation between public_transport_share**

```{r}
# Compute Pearson and Spearman correlations
correlation_pearson <- cor(final_dataset_cleaned2.0$public_transport_share, final_dataset_cleaned2.0$nb_stops, use = "complete.obs", method = "pearson")
correlation_spearman <- cor(final_dataset_cleaned2.0$public_transport_share, final_dataset_cleaned2.0$nb_stops, use = "complete.obs", method = "spearman")

# Print the results
cat("Pearson Correlation: ", correlation_pearson, "\n")
cat("Spearman Correlation: ", correlation_spearman, "\n")

# Scatterplot to visualize the relationship
library(ggplot2)

ggplot(final_dataset_cleaned2.0, aes(x = nb_stops, y = public_transport_share)) +
  geom_point(color = "blue", alpha = 0.6) +
  geom_smooth(method = "lm", color = "red") +
  labs(
    title = "Relationship Between Public Transport Share and Number of Stops",
    x = "Number of Stops",
    y = "Public Transport Share"
  ) +
  theme_minimal()
```

The Spearman correlation is stronger than the Pearson correlation, which
might indicate that the relationship is not strictly linear (fx.it could
plateau at higher numbers of stops or be influenced by outliers).

### Statistical Testing {#statistical-testing}

**Urban/Rural Classification vs. Preferred Transportation Mode**

```{r}
# Create urban/rural classification
final_dataset_cleaned2.0_5 <- final_dataset_cleaned2.0 %>%
  mutate(urban_rural = ifelse(population_density_2021 > 150, "Urban", "Rural"))

# Create contingency table
urban_transport_table <- final_dataset_cleaned2.0_5 %>%
  select(urban_rural, no_transport_share, on_foot_share, bicycle_share, 
         motorized_two_wheelers_share, car_truck_van_share, public_transport_share) %>%
  pivot_longer(cols = starts_with("no_transport_share"):starts_with("public_transport_share"),
               names_to = "Transport_Mode", values_to = "Share") %>%
  mutate(Transport_Mode = recode(
    Transport_Mode,
    "no_transport_share" = "No Transport",
    "on_foot_share" = "On Foot",
    "bicycle_share" = "Bicycle",
    "motorized_two_wheelers_share" = "Two-Wheelers",
    "car_truck_van_share" = "Car/Van",
    "public_transport_share" = "Public Transport"
  )) %>%
  group_by(urban_rural, Transport_Mode) %>%
  summarise(Total_Share = sum(Share), .groups = "drop") %>%
  pivot_wider(names_from = Transport_Mode, values_from = Total_Share, values_fill = 0)

# Convert to matrix
urban_transport_matrix <- urban_transport_table %>%
  select(-urban_rural) %>%
  as.matrix()

rownames(urban_transport_matrix) <- urban_transport_table$urban_rural

# Perform chi-squared test
chisq_test_urban_transport <- chisq.test(urban_transport_matrix)

# Results
chisq_test_urban_transport

```

There is evidence of a significant association between the variables.

**Socio-Professional Category vs. Car Ownership**

TO DO

# Discussion {#discussion}

-   Would also be interesting to perform a causal analysis

-   Eventually try to measure the impact of remote working on commute
    behavior (compare pre and post covid data)
